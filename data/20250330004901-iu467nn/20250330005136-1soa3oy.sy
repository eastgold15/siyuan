{"ID":"20250330005136-1soa3oy","Spec":"1","Type":"NodeDocument","Properties":{"id":"20250330005136-1soa3oy","title":"前端术语解读 - 编程思想类","type":"doc","updated":"20250510111012"},"Children":[{"ID":"20250510111012-s1ca42n","Type":"NodeThematicBreak","Properties":{"id":"20250510111012-s1ca42n","updated":"20250510111012"}},{"ID":"20250510111012-a65kngu","Type":"NodeParagraph","Properties":{"id":"20250510111012-a65kngu","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"title: 前端术语解读 - 编程思想类\ndate: 2025-03-30T00:51:36Z\nlastmod: 2025-05-10T10:47:59Z"}]},{"ID":"20250510111012-yyba05y","Type":"NodeThematicBreak","Properties":{"id":"20250510111012-yyba05y","updated":"20250510111012"}},{"ID":"20250510111012-ovuuc60","Type":"NodeThematicBreak","Properties":{"id":"20250510111012-ovuuc60","updated":"20250510111012"}},{"ID":"20250510111012-cbb5j22","Type":"NodeParagraph","Properties":{"id":"20250510111012-cbb5j22","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"title: 前端术语解读 - 编程思想类"},{"Type":"NodeBr","Data":"br"},{"Type":"NodeText","Data":"date: 2025-03-30T00:51:36Z"},{"Type":"NodeBr","Data":"br"},{"Type":"NodeText","Data":"lastmod: 2025-03-30T00:52:07Z"}]},{"ID":"20250510111012-eq7k07h","Type":"NodeThematicBreak","Properties":{"id":"20250510111012-eq7k07h","updated":"20250510111012"}},{"ID":"20250510111012-q7qy8g4","Type":"NodeBlockquote","Properties":{"id":"20250510111012-q7qy8g4","updated":"20250510111012"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20250510111012-z07gz8n","Type":"NodeParagraph","Properties":{"id":"20250510111012-z07gz8n","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"前端名词解读，本篇是设计思想类。"}]}]},{"ID":"20250510111012-8a44kza","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510111012-8a44kza","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"OOP 面向对象编程"}]},{"ID":"20250510111012-0v7jxto","Type":"NodeParagraph","Properties":{"id":"20250510111012-0v7jxto","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"OOP是面向对象编程（Object-Oriented Programming）的缩写"},{"Type":"NodeText","Data":"。它是一种编程范式，通过“对象”来建模和解决问题，这些对象是类的实例。在前端开发中，OOP主要应用于JavaScript语言。但是需要注意JavaScript在技术上是一门多范式语言，不仅仅支持面向对象，也支持命令式以及函数式编程风格。"}]},{"ID":"20250510111012-cftepz6","Type":"NodeParagraph","Properties":{"id":"20250510111012-cftepz6","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在前端开发里使用OOP可以带来以下好处："}]},{"ID":"20250510111012-xthdi53","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250510111012-xthdi53","updated":"20250510111012"},"Children":[{"ID":"20250510111012-e3ljq07","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250510111012-e3ljq07","updated":"20250510111012"},"Children":[{"ID":"20250510111012-nlclojh","Type":"NodeParagraph","Properties":{"id":"20250510111012-nlclojh","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"代码组织"},{"Type":"NodeText","Data":"：通过将相关属性和方法封装到类中，可以使代码更加有组织性和可维护性；"}]}]},{"ID":"20250510111012-e62pvh4","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250510111012-e62pvh4","updated":"20250510111012"},"Children":[{"ID":"20250510111012-6da318f","Type":"NodeParagraph","Properties":{"id":"20250510111012-6da318f","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"代码重用"},{"Type":"NodeText","Data":"：继承机制允许一个类从另一个类那里继承属性和方法，减少了重复代码；"}]}]},{"ID":"20250510111012-idtcvbx","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250510111012-idtcvbx","updated":"20250510111012"},"Children":[{"ID":"20250510111012-1s1ctbu","Type":"NodeParagraph","Properties":{"id":"20250510111012-1s1ctbu","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"易于维护"},{"Type":"NodeText","Data":"：因为代码被分割成独立的对象，所以更容易进行调试和更新；"}]}]},{"ID":"20250510111012-1zps9k4","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20250510111012-1zps9k4","updated":"20250510111012"},"Children":[{"ID":"20250510111012-l5hhp3e","Type":"NodeParagraph","Properties":{"id":"20250510111012-l5hhp3e","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"抽象"},{"Type":"NodeText","Data":"：可以通过定义接口或者父类隐藏复杂的实现细节，只暴露必要的部分给使用者。"}]}]}]},{"ID":"20250510111012-uewnk0g","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-uewnk0g","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"应用"}]},{"ID":"20250510111012-1x10yn1","Type":"NodeParagraph","Properties":{"id":"20250510111012-1x10yn1","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在现代JavaScript（ES6及以上版本）中，引入了class关键字来正式支持面向对象编程的概念，使得创建对象和实现继承变得更加直观和简单。例如："}]},{"ID":"20250510111012-1qfps0p","Type":"NodeParagraph","Properties":{"id":"20250510111012-1qfps0p","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-0fuz2cl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-0fuz2cl","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"dHM="},{"Type":"NodeCodeBlockCode","Data":"class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name);\n    this.breed = breed;\n  }\n\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\n\nlet d = new Dog('Mitzie', 'Dachshund');\nd.speak(); // 输出: Mitzie barks.\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-pplkn3v","Type":"NodeParagraph","Properties":{"id":"20250510111012-pplkn3v","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"这个例子展示了如何定义一个基类"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Animal"},{"Type":"NodeText","Data":"​和它的子类"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Dog"},{"Type":"NodeText","Data":"​，并通过"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"extends"},{"Type":"NodeText","Data":"​关键字实现继承，以及"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"super"},{"Type":"NodeText","Data":"​关键字调用父类的构造函数。"}]},{"ID":"20250510111012-fz2tiqh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510111012-fz2tiqh","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"MVC与MVVM"}]},{"ID":"20250510111012-5drgp10","Type":"NodeParagraph","Properties":{"id":"20250510111012-5drgp10","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在前端开发中，MVC 和 MVVM 是常见的设计模式，它们用于分离关注点，使得代码更加模块化、易于维护和扩展。"}]},{"ID":"20250510111012-knat72p","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-knat72p","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"MVC (Model-View-Controller)"}]},{"ID":"20250510111012-cab2pbw","Type":"NodeParagraph","Properties":{"id":"20250510111012-cab2pbw","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVC"},{"Type":"NodeText","Data":" 模式将应用程序分为三个核心组件："}]},{"ID":"20250510111012-u9xs25r","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-u9xs25r","updated":"20250510111012"},"Children":[{"ID":"20250510111012-msindve","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-msindve","updated":"20250510111012"},"Children":[{"ID":"20250510111012-qgdyopp","Type":"NodeParagraph","Properties":{"id":"20250510111012-qgdyopp","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Model（模型）"},{"Type":"NodeText","Data":"  ：负责处理应用的数据逻辑，直接管理数据、逻辑和规则。"}]}]},{"ID":"20250510111012-k0kf43v","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-k0kf43v","updated":"20250510111012"},"Children":[{"ID":"20250510111012-65inezj","Type":"NodeParagraph","Properties":{"id":"20250510111012-65inezj","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"View（视图）"},{"Type":"NodeText","Data":"  ：负责展示数据给用户，也就是UI部分。"}]}]},{"ID":"20250510111012-t16bmtg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-t16bmtg","updated":"20250510111012"},"Children":[{"ID":"20250510111012-jj16len","Type":"NodeParagraph","Properties":{"id":"20250510111012-jj16len","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Controller（控制器）"},{"Type":"NodeText","Data":"  ：作为Model和View之间的桥梁，接收输入并转换它为命令发给Model或View。"}]}]}]},{"ID":"20250510111012-rbd7ej3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-rbd7ej3","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"MVVM (Model-View-ViewModel)"}]},{"ID":"20250510111012-aevcyh0","Type":"NodeParagraph","Properties":{"id":"20250510111012-aevcyh0","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVVM"},{"Type":"NodeText","Data":" 是一种专门为简化用户界面的开发而设计的模式，它包括："}]},{"ID":"20250510111012-j5q0fhe","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-j5q0fhe","updated":"20250510111012"},"Children":[{"ID":"20250510111012-e7o7n8w","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-e7o7n8w","updated":"20250510111012"},"Children":[{"ID":"20250510111012-gayo501","Type":"NodeParagraph","Properties":{"id":"20250510111012-gayo501","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Model（模型）"},{"Type":"NodeText","Data":"  ：与MVC中的定义相同，处理业务逻辑和数据。"}]}]},{"ID":"20250510111012-tt3r9wc","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-tt3r9wc","updated":"20250510111012"},"Children":[{"ID":"20250510111012-algx47d","Type":"NodeParagraph","Properties":{"id":"20250510111012-algx47d","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"View（视图）"},{"Type":"NodeText","Data":"  ：用户界面，负责显示数据。"}]}]},{"ID":"20250510111012-r5lfh54","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-r5lfh54","updated":"20250510111012"},"Children":[{"ID":"20250510111012-otmcolz","Type":"NodeParagraph","Properties":{"id":"20250510111012-otmcolz","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"ViewModel（视图模型）"},{"Type":"NodeText","Data":"  ：连接Model和View的部分，负责暴露数据对象以及在Model或者View发生变化时进行同步。"}]}]}]},{"ID":"20250510111012-jjlsg6x","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-jjlsg6x","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"应用"}]},{"ID":"20250510111012-53ht3wn","Type":"NodeParagraph","Properties":{"id":"20250510111012-53ht3wn","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"假设有一个简单的待办事项应用。当你添加一个新的待办事项时，输入会发送到Controller，Controller会通知Model更新数据，然后Model通知View刷新显示内容。"}]},{"ID":"20250510111012-hq9xes3","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-hq9xes3","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"MVC"}]},{"ID":"20250510111012-y7cpmzy","Type":"NodeParagraph","Properties":{"id":"20250510111012-y7cpmzy","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"模型负责处理应用的数据逻辑和规则"},{"Type":"NodeText","Data":"。在我们的待办事项应用中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TodoItem"},{"Type":"NodeText","Data":"​可以作为一个模型，它包含了待办事项的详细信息以及相关的业务逻辑。"}]},{"ID":"20250510111012-podbz3i","Type":"NodeParagraph","Properties":{"id":"20250510111012-podbz3i","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-whjo7ct","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-whjo7ct","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"class TodoItem {\n    constructor(id, description) {\n        this.id = id;\n        this.description = description;\n        this.completed = false;\n    }\n\n    toggleCompleted() {\n        this.completed = !this.completed;\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-oj3uyhb","Type":"NodeParagraph","Properties":{"id":"20250510111012-oj3uyhb","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"视图负责呈现数据给用户，并且响应用户的交互"},{"Type":"NodeText","Data":"。在这个例子中，视图将展示待办事项列表，并提供添加新项目、完成项目的按钮等UI元素。"}]},{"ID":"20250510111012-okzuoan","Type":"NodeParagraph","Properties":{"id":"20250510111012-okzuoan","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"html"}]},{"ID":"20250510111012-w9b47bv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-w9b47bv","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"\u003cdiv id=\"todo-app\"\u003e\n    \u003cul id=\"todo-list\"\u003e\u003c/ul\u003e\n    \u003cinput type=\"text\" id=\"new-todo\" placeholder=\"New todo\"\u003e\n    \u003cbutton id=\"add-todo\"\u003eAdd\u003c/button\u003e\n\u003c/div\u003e\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-9cgqqrz","Type":"NodeParagraph","Properties":{"id":"20250510111012-9cgqqrz","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"JavaScript部分可能如下："}]},{"ID":"20250510111012-cmuwwmy","Type":"NodeParagraph","Properties":{"id":"20250510111012-cmuwwmy","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-gbxe03v","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-gbxe03v","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"function renderTodoList(todoItems) {\n    const todoListElement = document.getElementById('todo-list');\n    todoListElement.innerHTML = '';\n    todoItems.forEach(item =\u003e {\n        const li = document.createElement('li');\n        li.textContent = `${item.description} (${item.completed ? 'Completed' : 'Pending'})`;\n        todoListElement.appendChild(li);\n    });\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-2mesyfu","Type":"NodeParagraph","Properties":{"id":"20250510111012-2mesyfu","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"控制器是模型与视图之间的桥梁，它接收用户输入并更新模型或视图"},{"Type":"NodeText","Data":"。例如，当用户点击“Add”按钮时，控制器会获取输入框中的文本，创建一个新的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TodoItem"},{"Type":"NodeText","Data":"​实例，并更新视图以显示新的待办事项。"}]},{"ID":"20250510111012-5dcpsz5","Type":"NodeParagraph","Properties":{"id":"20250510111012-5dcpsz5","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-j7390ui","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-j7390ui","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"document.getElementById('add-todo').addEventListener('click', () =\u003e {\n    const newTodoText = document.getElementById('new-todo').value;\n    if (newTodoText.trim()) {\n        const newItem = new TodoItem(Date.now(), newTodoText);\n        // 假设有一个方法可以添加新的待办事项到模型中\n        addTodoItem(newItem);\n        renderTodoList(getAllTodoItems());\n        document.getElementById('new-todo').value = '';\n    }\n});\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-fmf7jrk","Type":"NodeParagraph","Properties":{"id":"20250510111012-fmf7jrk","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"通过这个简单的例子，我们可以看到MVC模式是如何工作的："}]},{"ID":"20250510111012-6ajgqts","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-6ajgqts","updated":"20250510111012"},"Children":[{"ID":"20250510111012-9hfv2zi","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-9hfv2zi","updated":"20250510111012"},"Children":[{"ID":"20250510111012-v0cm1i5","Type":"NodeParagraph","Properties":{"id":"20250510111012-v0cm1i5","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Model"},{"Type":"NodeText","Data":" ("},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TodoItem"},{"Type":"NodeText","Data":"​)：封装了待办事项的数据和行为。"}]}]},{"ID":"20250510111012-li2ib3c","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-li2ib3c","updated":"20250510111012"},"Children":[{"ID":"20250510111012-ocnbgz8","Type":"NodeParagraph","Properties":{"id":"20250510111012-ocnbgz8","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"View"},{"Type":"NodeText","Data":" (HTML + 渲染逻辑)：展示了待办事项列表，并提供了用户交互的界面。"}]}]},{"ID":"20250510111012-4ckmbjj","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-4ckmbjj","updated":"20250510111012"},"Children":[{"ID":"20250510111012-yrgu6ck","Type":"NodeParagraph","Properties":{"id":"20250510111012-yrgu6ck","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Controller"},{"Type":"NodeText","Data":" (事件监听器)：处理用户输入（如点击按钮），并根据输入更新模型或视图。"}]}]}]},{"ID":"20250510111012-th6hip9","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-th6hip9","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"MVVM"}]},{"ID":"20250510111012-dulpm4p","Type":"NodeParagraph","Properties":{"id":"20250510111012-dulpm4p","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"继续以待办事项应用为例，在MVVM架构下，你可能会使用像Vue.js这样的框架。ViewModel通过双向绑定机制自动同步Model和View之间的数据。当用户在View中更改待办事项的状态时，这些更改会自动反映在Model中，反之亦然。"}]},{"ID":"20250510111012-ug4n4oj","Type":"NodeParagraph","Properties":{"id":"20250510111012-ug4n4oj","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-lzt708e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-lzt708e","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// 简化的Vue示例代码\nnew Vue({\n  el: '#app',\n  data: {\n    todos: [\n      { text: '学习JavaScript', done: false },\n      { text: '学习Vue', done: false }\n    ]\n  },\n  methods: {\n    addTodo: function() {\n      this.todos.push({ text: this.newTodoText, done: false });\n      this.newTodoText = '';\n    }\n  }\n});\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-nw7xi1d","Type":"NodeParagraph","Properties":{"id":"20250510111012-nw7xi1d","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在这个简化的Vue.js示例中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"data"},{"Type":"NodeText","Data":"​属性充当了Model的角色，模板（HTML部分）是View，而Vue实例本身扮演着ViewModel的角色，负责管理数据和逻辑，并确保它们能正确地映射到View上。这样，开发者可以专注于数据和业务逻辑，而不必手动操作DOM来更新界面。"}]},{"ID":"20250510111012-ptve368","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-ptve368","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"区别"}]},{"ID":"20250510111012-fezt6pm","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250510111012-fezt6pm","updated":"20250510111012"},"Children":[{"ID":"20250510111012-mx4j1kf","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250510111012-mx4j1kf","updated":"20250510111012"},"Children":[{"ID":"20250510111012-qjtlq53","Type":"NodeParagraph","Properties":{"id":"20250510111012-qjtlq53","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"数据绑定机制"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510111012-8jn5un6","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-8jn5un6","updated":"20250510111012"},"Children":[{"ID":"20250510111012-zx81b5l","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-zx81b5l","updated":"20250510111012"},"Children":[{"ID":"20250510111012-f62mjmv","Type":"NodeParagraph","Properties":{"id":"20250510111012-f62mjmv","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVC"},{"Type":"NodeText","Data":"：通常依赖于手动的数据同步。控制器负责从模型获取数据，并更新视图，反之亦然。这通常需要编写额外的代码来保持视图和模型之间的一致性。"}]}]},{"ID":"20250510111012-xcm3101","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-xcm3101","updated":"20250510111012"},"Children":[{"ID":"20250510111012-e18u3d5","Type":"NodeParagraph","Properties":{"id":"20250510111012-e18u3d5","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVVM"},{"Type":"NodeText","Data":"：通过双向数据绑定自动同步视图(View)和视图模型(ViewModel)。这意味着当视图中的数据发生变化时，这些变化会自动反映在视图模型中，反之亦然，无需开发者手动进行数据同步。"}]}]}]}]},{"ID":"20250510111012-nevcdli","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250510111012-nevcdli","updated":"20250510111012"},"Children":[{"ID":"20250510111012-240isaf","Type":"NodeParagraph","Properties":{"id":"20250510111012-240isaf","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"角色职责"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510111012-4e3hvkj","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-4e3hvkj","updated":"20250510111012"},"Children":[{"ID":"20250510111012-wtvy312","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-wtvy312","updated":"20250510111012"},"Children":[{"ID":"20250510111012-lbc2qxm","Type":"NodeParagraph","Properties":{"id":"20250510111012-lbc2qxm","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVC"},{"Type":"NodeText","Data":"：控制器(Controller)作为中介者，接收用户输入并调用模型(Model)或视图(View)的方法来处理业务逻辑或更新界面。"}]}]},{"ID":"20250510111012-9nv7q4t","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-9nv7q4t","updated":"20250510111012"},"Children":[{"ID":"20250510111012-6k0goae","Type":"NodeParagraph","Properties":{"id":"20250510111012-6k0goae","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVVM"},{"Type":"NodeText","Data":"：视图模型(ViewModel)不仅充当了MVC中控制器的角色，还包含了视图的状态和行为逻辑。ViewModel是专门为视图准备的数据模型，它不直接引用视图，而是通过数据绑定与视图交互。"}]}]}]}]},{"ID":"20250510111012-q4l5b1a","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250510111012-q4l5b1a","updated":"20250510111012"},"Children":[{"ID":"20250510111012-op5p2ew","Type":"NodeParagraph","Properties":{"id":"20250510111012-op5p2ew","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"测试友好性"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510111012-zf8dxxa","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-zf8dxxa","updated":"20250510111012"},"Children":[{"ID":"20250510111012-v2wfmd1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-v2wfmd1","updated":"20250510111012"},"Children":[{"ID":"20250510111012-vs5c9xr","Type":"NodeParagraph","Properties":{"id":"20250510111012-vs5c9xr","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVC"},{"Type":"NodeText","Data":"：由于控制器直接处理用户输入并控制应用流程，可能需要模拟HTTP请求等环境来进行单元测试，增加了测试复杂度。"}]}]},{"ID":"20250510111012-639e26x","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-639e26x","updated":"20250510111012"},"Children":[{"ID":"20250510111012-sgz41bl","Type":"NodeParagraph","Properties":{"id":"20250510111012-sgz41bl","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVVM"},{"Type":"NodeText","Data":"：由于ViewModel不依赖于具体的UI技术，更容易进行单元测试。你可以单独对ViewModel进行测试，而不需要考虑视图的具体实现。"}]}]}]}]},{"ID":"20250510111012-0cz3mb9","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20250510111012-0cz3mb9","updated":"20250510111012"},"Children":[{"ID":"20250510111012-fvqyaog","Type":"NodeParagraph","Properties":{"id":"20250510111012-fvqyaog","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"使用场景"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510111012-5r0trec","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-5r0trec","updated":"20250510111012"},"Children":[{"ID":"20250510111012-iz79rm6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-iz79rm6","updated":"20250510111012"},"Children":[{"ID":"20250510111012-u06b5bt","Type":"NodeParagraph","Properties":{"id":"20250510111012-u06b5bt","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVC"},{"Type":"NodeText","Data":"：适用于传统的Web应用程序，尤其是那些后端渲染页面较多的应用。"}]}]},{"ID":"20250510111012-nb9ebp4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-nb9ebp4","updated":"20250510111012"},"Children":[{"ID":"20250510111012-5hg7dlk","Type":"NodeParagraph","Properties":{"id":"20250510111012-5hg7dlk","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVVM"},{"Type":"NodeText","Data":"：特别适合现代单页应用(SPA)，其中前端负责大部分的用户交互逻辑。Vue.js、Angular等框架都采用了MVVM模式。"}]}]}]}]}]},{"ID":"20250510111012-rbadi8s","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510111012-rbadi8s","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Duck Typing 鸭子类型"}]},{"ID":"20250510111012-c9r0auv","Type":"NodeParagraph","Properties":{"id":"20250510111012-c9r0auv","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"鸭子类型（Duck Typing）是动态类型语言中的一种概念，主要体现在对对象的行为的关注而非其具体的类型"},{"Type":"NodeText","Data":"。这一概念源于詹姆斯·惠特科姆·赖利的一句谚语：“如果它走起来像鸭子，叫起来像鸭子，那么它就是鸭子。”在编程领域，这意味着只要一个对象实现了所需的方法和属性，即使该对象不属于某个特定的类或接口，也能被视为某种类型并正常使用。"}]},{"ID":"20250510111012-xlkbmmk","Type":"NodeParagraph","Properties":{"id":"20250510111012-xlkbmmk","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"由于JavaScript 是一门动态类型语言，天然支持这种编程风格，所以在前端开发中广泛的使用鸭子类型（Duck Typing）。"}]},{"ID":"20250510111012-k1z4j4w","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-k1z4j4w","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"特点"}]},{"ID":"20250510111012-tquw9os","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250510111012-tquw9os","updated":"20250510111012"},"Children":[{"ID":"20250510111012-1gzo9yd","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250510111012-1gzo9yd","updated":"20250510111012"},"Children":[{"ID":"20250510111012-cxisy0i","Type":"NodeParagraph","Properties":{"id":"20250510111012-cxisy0i","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"核心思想"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510111012-3pwq0dp","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-3pwq0dp","updated":"20250510111012"},"Children":[{"ID":"20250510111012-86pu30v","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-86pu30v","updated":"20250510111012"},"Children":[{"ID":"20250510111012-hluxdl3","Type":"NodeParagraph","Properties":{"id":"20250510111012-hluxdl3","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"行为优先"},{"Type":"NodeText","Data":"：鸭子类型关注对象能否完成某项任务，而不关心对象的具体类型。"}]}]},{"ID":"20250510111012-tksdzcw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-tksdzcw","updated":"20250510111012"},"Children":[{"ID":"20250510111012-l2pkrwq","Type":"NodeParagraph","Properties":{"id":"20250510111012-l2pkrwq","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"动态绑定"},{"Type":"NodeText","Data":"：由于动态类型的特点，对象的类型在运行时才确定，因此可以通过方法的存在与否来进行类型验证。"}]}]}]}]},{"ID":"20250510111012-eptgtnd","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250510111012-eptgtnd","updated":"20250510111012"},"Children":[{"ID":"20250510111012-1oqcs3t","Type":"NodeParagraph","Properties":{"id":"20250510111012-1oqcs3t","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"优点"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510111012-ko95ppj","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-ko95ppj","updated":"20250510111012"},"Children":[{"ID":"20250510111012-xd6mcf4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-xd6mcf4","updated":"20250510111012"},"Children":[{"ID":"20250510111012-g7hkat2","Type":"NodeParagraph","Properties":{"id":"20250510111012-g7hkat2","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"灵活性高"},{"Type":"NodeText","Data":"：减少了代码间的耦合，提高了代码的重用性和适应性。"}]}]},{"ID":"20250510111012-cg428ii","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-cg428ii","updated":"20250510111012"},"Children":[{"ID":"20250510111012-869ojyo","Type":"NodeParagraph","Properties":{"id":"20250510111012-869ojyo","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"简化开发流程"},{"Type":"NodeText","Data":"：开发者不必担心严格的类型约束，可以根据需求快速实现新功能。"}]}]}]}]},{"ID":"20250510111012-kemuk3t","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250510111012-kemuk3t","updated":"20250510111012"},"Children":[{"ID":"20250510111012-8bikoy3","Type":"NodeParagraph","Properties":{"id":"20250510111012-8bikoy3","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"缺点"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510111012-5gliqoe","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-5gliqoe","updated":"20250510111012"},"Children":[{"ID":"20250510111012-buc7kcn","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-buc7kcn","updated":"20250510111012"},"Children":[{"ID":"20250510111012-cymt0al","Type":"NodeParagraph","Properties":{"id":"20250510111012-cymt0al","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"缺乏明确性"},{"Type":"NodeText","Data":"：可能导致代码难以理解和调试，因为缺少显式的类型信息。"}]}]},{"ID":"20250510111012-lqyxn0i","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-lqyxn0i","updated":"20250510111012"},"Children":[{"ID":"20250510111012-nrh6iga","Type":"NodeParagraph","Properties":{"id":"20250510111012-nrh6iga","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"潜在的风险"},{"Type":"NodeText","Data":"：如果没有正确处理缺失的方法，可能会导致运行时错误。"}]}]}]}]}]},{"ID":"20250510111012-rko91nu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-rko91nu","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"应用"}]},{"ID":"20250510111012-t0zs0r2","Type":"NodeParagraph","Properties":{"id":"20250510111012-t0zs0r2","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"通用事件处理器"}]},{"ID":"20250510111012-t31i9m5","Type":"NodeParagraph","Properties":{"id":"20250510111012-t31i9m5","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-6omnqew","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-6omnqew","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// 假设我们有两个对象，一个是按钮，另一个是链接\nconst button = {\n    click: () =\u003e console.log('Button clicked!')\n};\n\nconst link = {\n    click: () =\u003e console.log('Link clicked!')\n};\n\n// 定义一个通用的点击处理器函数\nfunction handleClick(element) {\n    if (typeof element.click === 'function') {\n        element.click();\n    } else {\n        console.error('Element does not have a click method.');\n    }\n}\n\nhandleClick(button); // 输出: Button clicked!\nhandleClick(link);   // 输出: Link clicked!\n\n// 另外一个不符合条件的对象\nconst div = {};\nhandleClick(div);      // 输出: Element does not have a click method.\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-qmmdpe7","Type":"NodeParagraph","Properties":{"id":"20250510111012-qmmdpe7","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在这个例子中，handleClick 函数并不关心 element 的具体类型，只需要知道它有没有 click 方法即可。这种方式使得代码更具灵活性和可扩展性。"}]},{"ID":"20250510111012-x69fb57","Type":"NodeParagraph","Properties":{"id":"20250510111012-x69fb57","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"插件化架构"}]},{"ID":"20250510111012-uwybgft","Type":"NodeParagraph","Properties":{"id":"20250510111012-uwybgft","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在一些框架中，如 React 插件或 Vue 组件库，鸭子类型可以帮助实现高度模块化的代码结构。"}]},{"ID":"20250510111012-7xrfaec","Type":"NodeParagraph","Properties":{"id":"20250510111012-7xrfaec","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-0h60ika","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-0h60ika","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"import React from 'react';\n\n// 定义一个通用的渲染函数\nfunction renderComponent(componentInstance) {\n    if (componentInstance.render \u0026\u0026 typeof componentInstance.render === 'function') {\n        return \u003cdiv\u003e{componentInstance.render()}\u003c/div\u003e;\n    } else {\n        throw new Error('Invalid component instance');\n    }\n}\n\n// 实现第一个组件\nclass MyFirstComponent extends React.Component {\n    render() {\n        return \u003cp\u003eThis is the first component.\u003c/p\u003e;\n    }\n}\n\n// 实现第二个组件\nclass MySecondComponent extends React.Component {\n    render() {\n        return \u003cp\u003eThis is the second component.\u003c/p\u003e;\n    }\n}\n\n// 使用渲染函数\nfunction App() {\n    const components = [\n        new MyFirstComponent(),\n        new MySecondComponent()\n    ];\n\n    return (\n        \u003cdiv\u003e\n            {components.map((comp, index) =\u003e (\n                \u003cdiv key={index}\u003e{renderComponent(comp)}\u003c/div\u003e\n            ))}\n        \u003c/div\u003e\n    );\n}\n\nexport default App;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-3a8lkqa","Type":"NodeParagraph","Properties":{"id":"20250510111012-3a8lkqa","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在这个例子中，renderComponent 函数只关心传入的对象是否有 render 方法，而不限制具体的类名或其他细节。这使得你可以轻松地添加新的组件，只要它们实现了 render 方法即可。"}]},{"ID":"20250510111012-gowrht2","Type":"NodeParagraph","Properties":{"id":"20250510111012-gowrht2","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"配置选项"}]},{"ID":"20250510111012-l0ors2b","Type":"NodeParagraph","Properties":{"id":"20250510111012-l0ors2b","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在许多 JavaScript 库中，配置选项通常是通过对象字面量传递的，这些对象可以有不同的形状，但只要包含所需的键值对即可。"}]},{"ID":"20250510111012-zk9xcli","Type":"NodeParagraph","Properties":{"id":"20250510111012-zk9xcli","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-5v0g84p","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-5v0g84p","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// 定义一个初始化函数\nfunction initialize(options) {\n    if (options.start \u0026\u0026 typeof options.start === 'function') {\n        options.start();\n    }\n\n    if (options.end \u0026\u0026 typeof options.end === 'function') {\n        options.end();\n    }\n\n    if (options.duration !== undefined \u0026\u0026 !isNaN(options.duration)) {\n        setTimeout(() =\u003e {\n            if (options.complete \u0026\u0026 typeof options.complete === 'function') {\n                options.complete();\n            }\n        }, options.duration);\n    }\n}\n\n// 初始化带有 start 和 end 回调的动画\ninitialize({\n    start: () =\u003e console.log('Animation started'),\n    end: () =\u003e console.log('Animation ended'),\n    duration: 1000\n});\n\n// 初始化只有 complete 回调的动画\ninitialize({\n    complete: () =\u003e console.log('Animation completed without explicit start and end')\n});\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-gel6dzr","Type":"NodeParagraph","Properties":{"id":"20250510111012-gel6dzr","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在这个例子中，initialize 函数根据提供的 options 对象的不同属性来执行相应的操作。只要 options 包含所需的方法或属性，就不必遵循固定的类层次结构。"}]},{"ID":"20250510111012-w00dvx6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510111012-w00dvx6","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Mutable/Immutable Data 可变/不可变 数据"}]},{"ID":"20250510111012-ge7zz8s","Type":"NodeParagraph","Properties":{"id":"20250510111012-ge7zz8s","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在编程中，  "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"\u0026quot;mutable\u0026quot;（可变的）指的是对象在其创建后可以被改变或修改"},{"Type":"NodeText","Data":"。相反的，  "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"\u0026quot;immutable\u0026quot;（不可变的）指的是对象一旦创建之后就不能再被修改"},{"Type":"NodeText","Data":"。在前端开发中，特别是在使用JavaScript这样的语言时，理解可变性和不可变性是非常重要的，因为这会影响到代码的行为、性能以及维护性。"}]},{"ID":"20250510111012-yj5uq0s","Type":"NodeParagraph","Properties":{"id":"20250510111012-yj5uq0s","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在前端开发中，尤其是在React等框架中提倡使用不可变数据结构来管理组件的状态。这样做可以帮助开发者更容易地理解和跟踪状态的变化，减少由于状态意外变更引起的bug，并简化调试过程。此外，利用不可变数据结构还可以优化应用的性能，比如通过浅比较（shallow comparison）快速判断前后状态是否发生变化，从而决定是否需要重新渲染组件。"}]},{"ID":"20250510111012-e45ig4m","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-e45ig4m","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"示例"}]},{"ID":"20250510111012-1whfi9b","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-1whfi9b","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"可变数据（Mutable Data）"}]},{"ID":"20250510111012-oelw72p","Type":"NodeParagraph","Properties":{"id":"20250510111012-oelw72p","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"当你处理的是可变数据时，你可以直接修改数据而不需要创建新的数据结构。例如，在JavaScript中，数组和对象都是默认可变的："}]},{"ID":"20250510111012-cty1oh4","Type":"NodeParagraph","Properties":{"id":"20250510111012-cty1oh4","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-8zd8ugv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-8zd8ugv","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"let arr = [1, 2, 3];\narr.push(4); // 直接修改了原数组\nconsole.log(arr); // 输出 [1, 2, 3, 4]\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-m0fiunb","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-m0fiunb","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"不可变数据（Immutable Data）"}]},{"ID":"20250510111012-6oui3zg","Type":"NodeParagraph","Properties":{"id":"20250510111012-6oui3zg","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"与之相对，不可变数据意味着任何“修改”都会产生一个新的数据结构，而原始数据不会被改变。这种方法有助于避免副作用，并且使得追踪状态变化更加容易。在JavaScript中实现不可变数据结构通常需要手动复制原有数据结构并进行修改，或者使用专门的库如Immutable.js。"}]},{"ID":"20250510111012-68oozx1","Type":"NodeParagraph","Properties":{"id":"20250510111012-68oozx1","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-4f4o2cc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-4f4o2cc","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"const arr = [1, 2, 3];\nconst newArr = [...arr, 4]; // 创建一个新数组而不是修改原有的\nconsole.log(arr); // 输出 [1, 2, 3]\nconsole.log(newArr); // 输出 [1, 2, 3, 4]\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-ap5ddl6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510111012-ap5ddl6","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Class 类"}]},{"ID":"20250510111012-g9egnq0","Type":"NodeParagraph","Properties":{"id":"20250510111012-g9egnq0","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在现代JavaScript（ES6及以后版本）中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"class"},{"Type":"NodeText","Data":"​提供了一种定义对象蓝图的清晰且简洁的语法。虽然JavaScript中的类本质上是基于原型的继承的一种语法糖，但它们使得面向对象编程的概念如类、构造函数、继承等更加直观和易于理解。"}]},{"ID":"20250510111012-3h1qfb5","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-3h1qfb5","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"基本概念"}]},{"ID":"20250510111012-k5fmh61","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-k5fmh61","updated":"20250510111012"},"Children":[{"ID":"20250510111012-kfyji7k","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-kfyji7k","updated":"20250510111012"},"Children":[{"ID":"20250510111012-t277o38","Type":"NodeParagraph","Properties":{"id":"20250510111012-t277o38","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"类（Class）"},{"Type":"NodeText","Data":"  ：定义了如何创建一个对象的类型。它包含了属性（数据成员）和方法（成员函数）。"}]}]},{"ID":"20250510111012-njgm5tu","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-njgm5tu","updated":"20250510111012"},"Children":[{"ID":"20250510111012-e6nocl4","Type":"NodeParagraph","Properties":{"id":"20250510111012-e6nocl4","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"构造函数（Constructor）"},{"Type":"NodeText","Data":"  ：特殊的方法用于创建和初始化类的一个实例对象。在类中定义时使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"constructor"},{"Type":"NodeText","Data":"​关键字。"}]}]},{"ID":"20250510111012-e79daus","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-e79daus","updated":"20250510111012"},"Children":[{"ID":"20250510111012-a5flael","Type":"NodeParagraph","Properties":{"id":"20250510111012-a5flael","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"继承（Inheritance）"},{"Type":"NodeText","Data":"  ：允许一个类继承另一个类的特征，这有助于代码重用和建立类之间的关系。"}]}]},{"ID":"20250510111012-5qik8wp","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-5qik8wp","updated":"20250510111012"},"Children":[{"ID":"20250510111012-w0954w3","Type":"NodeParagraph","Properties":{"id":"20250510111012-w0954w3","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"方法（Methods）"},{"Type":"NodeText","Data":"  ：定义在类内部的函数，描述了该类的对象可以执行的行为。"}]}]}]},{"ID":"20250510111012-bwnfko3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-bwnfko3","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"示例"}]},{"ID":"20250510111012-c2tv1je","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-c2tv1je","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"定义类"}]},{"ID":"20250510111012-cgxhw0g","Type":"NodeParagraph","Properties":{"id":"20250510111012-cgxhw0g","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-2273xry","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-2273xry","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"class Rectangle {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n    }\n\n    getArea() {\n        return this.width * this.height;\n    }\n\n    getPerimeter() {\n        return 2 * (this.width + this.height);\n    }\n}\n\nconst myRectangle = new Rectangle(10, 20);\nconsole.log(myRectangle.getArea()); // 输出: 200\nconsole.log(myRectangle.getPerimeter()); // 输出: 60\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-b1c4gbd","Type":"NodeParagraph","Properties":{"id":"20250510111012-b1c4gbd","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在这个例子中，我们定义了一个名为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rectangle"},{"Type":"NodeText","Data":"​的类，它有两个属性："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"width"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"height"},{"Type":"NodeText","Data":"​，以及两个方法："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"getArea"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"getPerimeter"},{"Type":"NodeText","Data":"​。通过"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"new Rectangle(10, 20)"},{"Type":"NodeText","Data":"​创建了一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rectangle"},{"Type":"NodeText","Data":"​类的实例，并调用了它的方法来获取面积和周长。"}]},{"ID":"20250510111012-z9jx7zy","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-z9jx7zy","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"继承"}]},{"ID":"20250510111012-89ajmv0","Type":"NodeParagraph","Properties":{"id":"20250510111012-89ajmv0","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"我们可以从一个已有的类派生出新的类，新类将自动获得父类的所有属性和方法，并可以添加或覆盖这些特性。"}]},{"ID":"20250510111012-b8vkqup","Type":"NodeParagraph","Properties":{"id":"20250510111012-b8vkqup","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-0hadryh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-0hadryh","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"class Square extends Rectangle {\n    constructor(sideLength) {\n        super(sideLength, sideLength); // 调用父类的构造函数\n    }\n\n    // 可以添加或覆盖方法\n    isSquare() {\n        return true; // 对于正方形总是返回true\n    }\n}\n\nconst mySquare = new Square(15);\nconsole.log(mySquare.getArea()); // 输出: 225\nconsole.log(mySquare.isSquare()); // 输出: true\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-j4fbpyd","Type":"NodeParagraph","Properties":{"id":"20250510111012-j4fbpyd","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"这里，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Square"},{"Type":"NodeText","Data":"​类继承自"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rectangle"},{"Type":"NodeText","Data":"​类，因此它可以访问"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rectangle"},{"Type":"NodeText","Data":"​的所有方法。此外，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Square"},{"Type":"NodeText","Data":"​还定义了自己的方法"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"isSquare"},{"Type":"NodeText","Data":"​，表明任何"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Square"},{"Type":"NodeText","Data":"​实例都是正方形。"}]},{"ID":"20250510111012-bwzby4g","Type":"NodeParagraph","Properties":{"id":"20250510111012-bwzby4g","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"通过这种方式，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"class"},{"Type":"NodeText","Data":"​关键字使得JavaScript中的面向对象编程更加直观和高效，支持了诸如封装、继承等重要概念，同时也简化了代码结构。"}]},{"ID":"20250510111012-xn2fu1g","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510111012-xn2fu1g","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"FP 函数式编程"}]},{"ID":"20250510111012-f22q164","Type":"NodeParagraph","Properties":{"id":"20250510111012-f22q164","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"函数式编程（Functional Programming）是一种编程范式，它将计算视为数学函数的求值，避免了改变状态和可变数据"},{"Type":"NodeText","Data":"。函数式编程鼓励使用纯函数、高阶函数以及不可变数据结构等概念，使得代码更加简洁、易于理解和测试。"}]},{"ID":"20250510111012-j4wzbyb","Type":"NodeParagraph","Properties":{"id":"20250510111012-j4wzbyb","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在 JavaScript 这样的语言中，由于其天生支持闭包和高阶函数等特性，函数式编程变得非常流行。利用函数式编程的思想，可以帮助开发者写出更加模块化、更具有复用性的代码，同时也能够提高代码的可靠性和开发效率。流行的前端框架和库，如 React 或者 lodash 等，都或多或少地采用了函数式编程的概念。"}]},{"ID":"20250510111012-kpiubqm","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-kpiubqm","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"示例"}]},{"ID":"20250510111012-vvwbk0y","Type":"NodeParagraph","Properties":{"id":"20250510111012-vvwbk0y","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"假设我们有一个数组，里面包含了一些用户的对象，每个对象都有一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"age"},{"Type":"NodeText","Data":"​ 属性表示用户的年龄。我们的目标是过滤出所有成年人（年龄大于等于18岁），然后创建一个新的数组，其中只包含这些成年人的名字。"}]},{"ID":"20250510111012-qvkrr23","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-qvkrr23","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"非函数式编程"}]},{"ID":"20250510111012-pqgs0sj","Type":"NodeParagraph","Properties":{"id":"20250510111012-pqgs0sj","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-ckzxl93","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-ckzxl93","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"let users = [\n  { name: \"Alice\", age: 25 },\n  { name: \"Bob\", age: 17 },\n  { name: \"Carol\", age: 30 }\n];\n\nlet adultNames = [];\nfor (let i = 0; i \u003c users.length; i++) {\n  if (users[i].age \u003e= 18) {\n    adultNames.push(users[i].name);\n  }\n}\nconsole.log(adultNames); // 输出 [\"Alice\", \"Carol\"]\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-b4j5rks","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-b4j5rks","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"函数式编程"}]},{"ID":"20250510111012-7nikzzg","Type":"NodeParagraph","Properties":{"id":"20250510111012-7nikzzg","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"使用函数式编程的思想，我们可以利用 JavaScript 的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"filter"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​ 方法来更简洁地完成同样的任务。"}]},{"ID":"20250510111012-jgs1svj","Type":"NodeParagraph","Properties":{"id":"20250510111012-jgs1svj","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-4vlsh6g","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-4vlsh6g","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"const users = [\n  { name: \"Alice\", age: 25 },\n  { name: \"Bob\", age: 17 },\n  { name: \"Carol\", age: 30 }\n];\n\nconst adultNames = users\n  .filter(user =\u003e user.age \u003e= 18) // 过滤出年龄大于等于18的用户\n  .map(user =\u003e user.name); // 将过滤后的用户对象转换为名字\n\nconsole.log(adultNames); // 输出 [\"Alice\", \"Carol\"]\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-143lb8t","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510111012-143lb8t","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Hooks 钩子"}]},{"ID":"20250510111012-2r95kh2","Type":"NodeParagraph","Properties":{"id":"20250510111012-2r95kh2","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在前端开发中，“Hooks” 概念最先由 React 提出。"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Hooks允许函数组件拥有状态和生命周期方法等类组件的特性，而无需编写类"},{"Type":"NodeText","Data":"。它们使得代码更加简洁、易于理解和测试。"}]},{"ID":"20250510111012-b2v5qi3","Type":"NodeParagraph","Properties":{"id":"20250510111012-b2v5qi3","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"从更广泛的角度来看，  "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"“Hook”可以被理解为一种设计模式或机制，它允许函数或模块之间以一种更加动态和灵活的方式进行交互"},{"Type":"NodeText","Data":"。具体来说，Hook通常指的是一个函数，该函数可以在不修改原始代码的情况下扩展或改变某些行为。这种模式不仅限于React框架，实际上，在其他编程环境和语言中也有类似的概念。"}]},{"ID":"20250510111012-lk5jp7u","Type":"NodeParagraph","Properties":{"id":"20250510111012-lk5jp7u","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在React中，Hooks 存在以下基本概念"}]},{"ID":"20250510111012-183xvlw","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-183xvlw","updated":"20250510111012"},"Children":[{"ID":"20250510111012-t08x7d2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-t08x7d2","updated":"20250510111012"},"Children":[{"ID":"20250510111012-sqay618","Type":"NodeParagraph","Properties":{"id":"20250510111012-sqay618","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"State Hook"},{"Type":"NodeText","Data":"：使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"useState"},{"Type":"NodeText","Data":"​来为函数组件添加状态。"}]}]},{"ID":"20250510111012-t3a4gm2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-t3a4gm2","updated":"20250510111012"},"Children":[{"ID":"20250510111012-av5hqtn","Type":"NodeParagraph","Properties":{"id":"20250510111012-av5hqtn","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Effect Hook"},{"Type":"NodeText","Data":"：使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"useEffect"},{"Type":"NodeText","Data":"​来执行副作用操作，如数据获取、订阅或手动DOM更新等。"}]}]},{"ID":"20250510111012-ksaa9zp","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-ksaa9zp","updated":"20250510111012"},"Children":[{"ID":"20250510111012-kp3kz8g","Type":"NodeParagraph","Properties":{"id":"20250510111012-kp3kz8g","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"自定义Hooks"},{"Type":"NodeText","Data":"：封装可复用的逻辑，便于在多个组件间共享功能。"}]}]}]},{"ID":"20250510111012-rtorqr0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-rtorqr0","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"示例"}]},{"ID":"20250510111012-0pf41ik","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-0pf41ik","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在React中的 Hooks"}]},{"ID":"20250510111012-khcze4k","Type":"NodeParagraph","Properties":{"id":"20250510111012-khcze4k","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"State Hook"},{"Type":"NodeText","Data":"：下面的例子展示了如何使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"useState"},{"Type":"NodeText","Data":"​ 来管理一个计数器的状态："}]},{"ID":"20250510111012-a8vf9h8","Type":"NodeParagraph","Properties":{"id":"20250510111012-a8vf9h8","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-zvn550n","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-zvn550n","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"import React, { useState } from 'react';\n\nfunction Counter() {\n    // 使用useState初始化状态，count是当前状态，setCount是更新状态的函数\n    const [count, setCount] = useState(0);\n\n    return (\n        \u003cdiv\u003e\n            \u003cp\u003eYou clicked {count} times\u003c/p\u003e\n            \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e\n                Click me\n            \u003c/button\u003e\n        \u003c/div\u003e\n    );\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-zhzpk3u","Type":"NodeParagraph","Properties":{"id":"20250510111012-zhzpk3u","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Effect Hook"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"useEffect"},{"Type":"NodeText","Data":"​ 可以用来处理组件的副作用，比如加载数据或设置订阅等。下面的例子展示了一个组件在挂载时获取数据并在卸载时清理副作用的操作："}]},{"ID":"20250510111012-bkr7d0w","Type":"NodeParagraph","Properties":{"id":"20250510111012-bkr7d0w","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-rsahya8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-rsahya8","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"import React, { useState, useEffect } from 'react';\n\nfunction FriendStatus(props) {\n    const [isOnline, setIsOnline] = useState(null);\n\n    useEffect(() =\u003e {\n        function handleStatusChange(status) {\n            setIsOnline(status.isOnline);\n        }\n\n        // 模拟订阅好友状态\n        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n        // 清理副作用\n        return () =\u003e {\n            ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n        };\n    }, [props.friend.id]); // 只有当friend.id改变时才重新执行effect\n\n    if (isOnline === null) {\n        return 'Loading...';\n    }\n    return isOnline ? 'Online' : 'Offline';\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-szgbvru","Type":"NodeParagraph","Properties":{"id":"20250510111012-szgbvru","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在这个例子中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"useEffect"},{"Type":"NodeText","Data":"​用于模拟监听朋友在线状态的变化，并且在组件卸载时取消了这个监听，避免了潜在的内存泄漏问题。"}]},{"ID":"20250510111012-2ynynec","Type":"NodeParagraph","Properties":{"id":"20250510111012-2ynynec","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"自定义Hooks"},{"Type":"NodeText","Data":"：自定义Hooks让我们可以从不同的组件中提取组件逻辑到可重用的函数中。例如，我们可以创建一个自定义Hook来简化上述检查好友状态的功能："}]},{"ID":"20250510111012-zcsn9p9","Type":"NodeParagraph","Properties":{"id":"20250510111012-zcsn9p9","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-yo812ez","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-yo812ez","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"function useFriendStatus(friendID) {\n    const [isOnline, setIsOnline] = useState(null);\n\n    useEffect(() =\u003e {\n        function handleStatusChange(status) {\n            setIsOnline(status.isOnline);\n        }\n\n        ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\n        return () =\u003e {\n            ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\n        };\n    }, [friendID]);\n\n    return isOnline;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-xkp8v76","Type":"NodeParagraph","Properties":{"id":"20250510111012-xkp8v76","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"然后，在其他组件中可以这样使用这个自定义Hook："}]},{"ID":"20250510111012-2gcevct","Type":"NodeParagraph","Properties":{"id":"20250510111012-2gcevct","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-d0gticz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-d0gticz","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"function FriendStatusWithCustomHook(props) {\n    const isOnline = useFriendStatus(props.friend.id);\n\n    if (isOnline === null) {\n        return 'Loading...';\n    }\n    return isOnline ? 'Online' : 'Offline';\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-6h4x6w3","Type":"NodeParagraph","Properties":{"id":"20250510111012-6h4x6w3","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"通过这种方式，Hooks不仅简化了React组件的编写方式，还提高了代码的复用性和可读性。"}]},{"ID":"20250510111012-qc6py47","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-qc6py47","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"非React环境中的Hooks"}]},{"ID":"20250510111012-36txn19","Type":"NodeParagraph","Properties":{"id":"20250510111012-36txn19","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"脱离React来讨论Hooks，我们可以从以下几个方面来理解："}]},{"ID":"20250510111012-6b2ixii","Type":"NodeParagraph","Properties":{"id":"20250510111012-6b2ixii","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"插件系统或扩展点"},{"Type":"NodeText","Data":"： 在许多应用程序或框架中，开发者可以通过定义特定的“钩子”（hooks）或者回调函数来扩展默认行为。例如，在Web开发中，Express.js中间件机制就可以看作是一种Hook实现方式。你可以通过添加中间件来处理请求之前或之后的行为。"}]},{"ID":"20250510111012-bhs4eeo","Type":"NodeParagraph","Properties":{"id":"20250510111012-bhs4eeo","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-dtye8na","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-dtye8na","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"const express = require('express');\nconst app = express();\n\n// 这里的中间件就是一个hook的例子\napp.use((req, res, next) =\u003e {\n    console.log('Request received');\n    next(); // 调用下一个中间件或路由处理器\n});\n\napp.get('/', (req, res) =\u003e {\n    res.send('Hello World!');\n});\n\napp.listen(3000, () =\u003e console.log('Server started'));\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-4wty74b","Type":"NodeParagraph","Properties":{"id":"20250510111012-4wty74b","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"事件监听器"},{"Type":"NodeText","Data":"： 在JavaScript中，事件驱动编程也是利用了类似的Hook概念。比如，DOM事件监听器允许你在特定事件发生时执行自定义逻辑。"}]},{"ID":"20250510111012-ybkdkx3","Type":"NodeParagraph","Properties":{"id":"20250510111012-ybkdkx3","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-ux7xrgq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-ux7xrgq","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"document.getElementById('myButton').addEventListener('click', function(event) {\n    console.log('Button clicked');\n});\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-mcxx3i6","Type":"NodeParagraph","Properties":{"id":"20250510111012-mcxx3i6","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"生命周期回调"},{"Type":"NodeText","Data":"： 在Node.js中，某些模块提供了生命周期钩子，允许你在特定时刻插入自己的逻辑。例如，Mocha测试框架允许你定义"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"beforeEach"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"afterEach"},{"Type":"NodeText","Data":"​等钩子来设置测试环境或清理资源。"}]},{"ID":"20250510111012-9an7224","Type":"NodeParagraph","Properties":{"id":"20250510111012-9an7224","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-i4yfhkl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-i4yfhkl","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"describe('Array', function() {\n  beforeEach(function() {\n    this.arr = [1, 2, 3];\n  });\n\n  it('should contain 3 elements', function() {\n    assert.equal(this.arr.length, 3);\n  });\n});\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-y2qo0wj","Type":"NodeParagraph","Properties":{"id":"20250510111012-y2qo0wj","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"自定义Hook"},{"Type":"NodeText","Data":"： 在非React环境中，我们也可以创建自己的Hook来复用逻辑。比如，我们可以创建一个通用的日志记录Hook来统一管理日志输出。"}]},{"ID":"20250510111012-25hsh46","Type":"NodeParagraph","Properties":{"id":"20250510111012-25hsh46","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-i4ud1r5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-i4ud1r5","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"function useLogger(prefix) {\n    return function log(message) {\n        console.log(`[${prefix}] ${message}`);\n    };\n}\n\nconst logger = useLogger('INFO');\nlogger('This is a log message');\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-bhz2wdl","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-bhz2wdl","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20250510111012-cgmasbk","Type":"NodeParagraph","Properties":{"id":"20250510111012-cgmasbk","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"总的来说，无论是React中的Hooks还是其他环境下的类似概念，它们的核心思想都是提供一种机制，让开发者能够在不修改原有代码的基础上，通过预定义的“入口点”或“钩子”来注入额外的功能或逻辑。这种方式有助于提高代码的模块化程度、可维护性和复用性。因此，虽然React将“Hooks”这一概念推广开来，但实际上，这种模式在软件开发中有更广泛的应用。"}]},{"ID":"20250510111012-tubsg47","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510111012-tubsg47","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Options API 选项式API"}]},{"ID":"20250510111012-98k386t","Type":"NodeParagraph","Properties":{"id":"20250510111012-98k386t","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"选项式API（Options API）是Vue.js早期版本中用于组织组件逻辑的主要方式，特别是在Vue 2中得到了广泛应用，并在Vue 3中继续得到支持。它"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"通过将组件的不同特性（如数据、计算属性、方法、生命周期钩子等）分门别类地定义在一个对象的各个选项中来构建Vue组件"},{"Type":"NodeText","Data":"。"}]},{"ID":"20250510111012-w419or4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-w419or4","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"核心"}]},{"ID":"20250510111012-dh9s8tj","Type":"NodeParagraph","Properties":{"id":"20250510111012-dh9s8tj","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"选项式API的核心在于它 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"提供了一种结构化的方式来定义组件的不同方面，每个方面都对应于组件对象的一个属性"},{"Type":"NodeText","Data":"。这种方式使得代码看起来非常直观和有条理，尤其适合初学者理解和使用。"}]},{"ID":"20250510111012-fbyy8gc","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-fbyy8gc","updated":"20250510111012"},"Children":[{"ID":"20250510111012-ulkaltk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-ulkaltk","updated":"20250510111012"},"Children":[{"ID":"20250510111012-2wucacx","Type":"NodeParagraph","Properties":{"id":"20250510111012-2wucacx","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"data"},{"Type":"NodeText","Data":"：定义组件的状态（即响应式数据）。可以是一个函数（在Vue 2中对于单文件组件必须是函数，在Vue 3中对于所有组件都是函数），该函数返回一个包含状态的对象。"}]}]},{"ID":"20250510111012-5byh2lr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-5byh2lr","updated":"20250510111012"},"Children":[{"ID":"20250510111012-s7bnxtq","Type":"NodeParagraph","Properties":{"id":"20250510111012-s7bnxtq","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"methods"},{"Type":"NodeText","Data":"：定义组件内使用的函数，这些函数可以改变组件的状态或触发其他操作。"}]}]},{"ID":"20250510111012-9jbuk4o","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-9jbuk4o","updated":"20250510111012"},"Children":[{"ID":"20250510111012-i3wgqsn","Type":"NodeParagraph","Properties":{"id":"20250510111012-i3wgqsn","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"computed"},{"Type":"NodeText","Data":"：定义计算属性，这些属性基于其他数据进行计算，且只有当依赖的数据发生变化时才会重新计算。"}]}]},{"ID":"20250510111012-av4b0md","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-av4b0md","updated":"20250510111012"},"Children":[{"ID":"20250510111012-xezczse","Type":"NodeParagraph","Properties":{"id":"20250510111012-xezczse","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"watch"},{"Type":"NodeText","Data":"：监听特定数据的变化，并在数据变化时执行相应的回调函数。"}]}]},{"ID":"20250510111012-kukyj8h","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-kukyj8h","updated":"20250510111012"},"Children":[{"ID":"20250510111012-5b2jihr","Type":"NodeParagraph","Properties":{"id":"20250510111012-5b2jihr","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"生命周期钩子"},{"Type":"NodeText","Data":"：例如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"created"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mounted"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"updated"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"beforeDestroy"},{"Type":"NodeText","Data":"​等，允许你在组件生命周期的不同阶段执行自定义逻辑。"}]}]}]},{"ID":"20250510111012-tunkz12","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-tunkz12","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"示例"}]},{"ID":"20250510111012-2dmrgnf","Type":"NodeParagraph","Properties":{"id":"20250510111012-2dmrgnf","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"vue"}]},{"ID":"20250510111012-p6saaml","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-p6saaml","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"\u003ctemplate\u003e\n  \u003cdiv\u003e\n    \u003cp\u003eCount: {{ count }}\u003c/p\u003e\n    \u003cbutton @click=\"increment\"\u003eIncrement\u003c/button\u003e\n    \u003cp\u003eDouble Count: {{ doubleCount }}\u003c/p\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cscript\u003e\nexport default {\n  // 定义组件的状态\n  data() {\n    return {\n      count: 0,\n    };\n  },\n  // 计算属性\n  computed: {\n    doubleCount() {\n      return this.count * 2;\n    },\n  },\n  // 方法\n  methods: {\n    increment() {\n      this.count++;\n    },\n  },\n  // 生命周期钩子\n  mounted() {\n    console.log('Component has been mounted.');\n  },\n};\n\u003c/script\u003e\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-7i92h51","Type":"NodeParagraph","Properties":{"id":"20250510111012-7i92h51","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在这个例子中："}]},{"ID":"20250510111012-wb6vqwf","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-wb6vqwf","updated":"20250510111012"},"Children":[{"ID":"20250510111012-3dx1dh9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-3dx1dh9","updated":"20250510111012"},"Children":[{"ID":"20250510111012-lbif1yk","Type":"NodeParagraph","Properties":{"id":"20250510111012-lbif1yk","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"data"},{"Type":"NodeText","Data":"：初始化了一个名为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"count"},{"Type":"NodeText","Data":"​的状态变量。"}]}]},{"ID":"20250510111012-mha5mnb","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-mha5mnb","updated":"20250510111012"},"Children":[{"ID":"20250510111012-izj45cx","Type":"NodeParagraph","Properties":{"id":"20250510111012-izj45cx","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"computed"},{"Type":"NodeText","Data":"：定义了一个计算属性"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"doubleCount"},{"Type":"NodeText","Data":"​，它基于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"count"},{"Type":"NodeText","Data":"​值进行计算。"}]}]},{"ID":"20250510111012-tk7xml9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-tk7xml9","updated":"20250510111012"},"Children":[{"ID":"20250510111012-gdwrcp7","Type":"NodeParagraph","Properties":{"id":"20250510111012-gdwrcp7","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"methods"},{"Type":"NodeText","Data":"：定义了一个名为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"increment"},{"Type":"NodeText","Data":"​的方法，用于增加"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"count"},{"Type":"NodeText","Data":"​的值。"}]}]},{"ID":"20250510111012-8i1t5s2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-8i1t5s2","updated":"20250510111012"},"Children":[{"ID":"20250510111012-bpdea9p","Type":"NodeParagraph","Properties":{"id":"20250510111012-bpdea9p","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"mounted"},{"Type":"NodeText","Data":"：生命周期钩子，当组件挂载到DOM后会自动调用，这里用来打印一条消息到控制台。"}]}]}]},{"ID":"20250510111012-ouc7hz6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510111012-ouc7hz6","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Composition API 组合式API"}]},{"ID":"20250510111012-eek8f4y","Type":"NodeParagraph","Properties":{"id":"20250510111012-eek8f4y","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Vue 3引入的组合式API（Composition API）是一种新的组织和复用逻辑的方式，它为开发者提供了更大的灵活性来构建Vue组件。与选项式API（Options API）不同，组合式API允许你基于功能而非类型来组织代码。"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件"},{"Type":"NodeText","Data":"。"}]},{"ID":"20250510111012-m5lm10w","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-m5lm10w","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"核心"}]},{"ID":"20250510111012-eekhy1a","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250510111012-eekhy1a","updated":"20250510111012"},"Children":[{"ID":"20250510111012-jkkjky0","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250510111012-jkkjky0","updated":"20250510111012"},"Children":[{"ID":"20250510111012-bf5pp6k","Type":"NodeParagraph","Properties":{"id":"20250510111012-bf5pp6k","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"setup函数"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510111012-comepmp","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-comepmp","updated":"20250510111012"},"Children":[{"ID":"20250510111012-4usstam","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-4usstam","updated":"20250510111012"},"Children":[{"ID":"20250510111012-18ba1c0","Type":"NodeParagraph","Properties":{"id":"20250510111012-18ba1c0","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在Vue 3中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"setup"},{"Type":"NodeText","Data":"​函数是使用组合式API的入口点。它在组件创建之前执行，并返回一个对象，该对象中的属性将暴露给模板和其他选项。"}]}]}]}]},{"ID":"20250510111012-166co1m","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250510111012-166co1m","updated":"20250510111012"},"Children":[{"ID":"20250510111012-p4gk6ge","Type":"NodeParagraph","Properties":{"id":"20250510111012-p4gk6ge","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"响应式数据"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510111012-1dek7p6","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-1dek7p6","updated":"20250510111012"},"Children":[{"ID":"20250510111012-hd264sw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-hd264sw","updated":"20250510111012"},"Children":[{"ID":"20250510111012-yh1m717","Type":"NodeParagraph","Properties":{"id":"20250510111012-yh1m717","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Vue 3提供了一系列用于创建响应式数据的方法，如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ref"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"reactive"},{"Type":"NodeText","Data":"​。这些方法使得你可以轻松地创建能够自动追踪更新的数据源。"}]}]}]}]},{"ID":"20250510111012-xsan1ip","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250510111012-xsan1ip","updated":"20250510111012"},"Children":[{"ID":"20250510111012-hzdrz8d","Type":"NodeParagraph","Properties":{"id":"20250510111012-hzdrz8d","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"生命周期钩子"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510111012-t070yn7","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-t070yn7","updated":"20250510111012"},"Children":[{"ID":"20250510111012-x6ix8qb","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-x6ix8qb","updated":"20250510111012"},"Children":[{"ID":"20250510111012-9nqv0bn","Type":"NodeParagraph","Properties":{"id":"20250510111012-9nqv0bn","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"组合式API提供了与Vue 2相似的生命周期钩子，但它们以函数的形式存在，例如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"onMounted"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"onUpdated"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"onUnmounted"},{"Type":"NodeText","Data":"​等。"}]}]}]}]},{"ID":"20250510111012-frrsujc","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20250510111012-frrsujc","updated":"20250510111012"},"Children":[{"ID":"20250510111012-4d0vsm5","Type":"NodeParagraph","Properties":{"id":"20250510111012-4d0vsm5","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"计算属性和监听器"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510111012-5hkazt9","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-5hkazt9","updated":"20250510111012"},"Children":[{"ID":"20250510111012-6tl2mgh","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-6tl2mgh","updated":"20250510111012"},"Children":[{"ID":"20250510111012-6tdeq8t","Type":"NodeParagraph","Properties":{"id":"20250510111012-6tdeq8t","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"computed"},{"Type":"NodeText","Data":"​可以创建计算属性，它会根据其依赖项自动更新。使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"watch"},{"Type":"NodeText","Data":"​可以监听特定数据的变化，并在变化时执行副作用操作。"}]}]}]}]},{"ID":"20250510111012-pw04pez","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20250510111012-pw04pez","updated":"20250510111012"},"Children":[{"ID":"20250510111012-6vbynuw","Type":"NodeParagraph","Properties":{"id":"20250510111012-6vbynuw","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"自定义逻辑复用"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510111012-ajuaujr","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-ajuaujr","updated":"20250510111012"},"Children":[{"ID":"20250510111012-7oc9v8t","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-7oc9v8t","updated":"20250510111012"},"Children":[{"ID":"20250510111012-bb8uyqq","Type":"NodeParagraph","Properties":{"id":"20250510111012-bb8uyqq","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"通过将相关逻辑封装到可复用的函数中，组合式API使得逻辑复用变得非常简单。这些函数通常被称为“hooks”，尽管Vue 3本身并没有直接使用这个术语。"}]}]}]}]}]},{"ID":"20250510111012-pkfnajv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-pkfnajv","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"示例"}]},{"ID":"20250510111012-03e3n0n","Type":"NodeParagraph","Properties":{"id":"20250510111012-03e3n0n","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"简单计数器"}]},{"ID":"20250510111012-057g2bx","Type":"NodeParagraph","Properties":{"id":"20250510111012-057g2bx","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"vue"}]},{"ID":"20250510111012-i8h5f4j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-i8h5f4j","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"\u003ctemplate\u003e\n  \u003cdiv\u003e\n    \u003cp\u003eCount: {{ count }}\u003c/p\u003e\n    \u003cbutton @click=\"increment\"\u003eIncrement\u003c/button\u003e\n    \u003cbutton @click=\"decrement\"\u003eDecrement\u003c/button\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cscript\u003e\nimport { ref, computed } from 'vue';\n\nexport default {\n  setup() {\n    // 创建响应式状态\n    const count = ref(0);\n\n    // 定义修改状态的方法\n    const increment = () =\u003e { count.value++; };\n    const decrement = () =\u003e { count.value--; };\n\n    // 可选：创建计算属性\n    const doubleCount = computed(() =\u003e count.value * 2);\n\n    return {\n      count,\n      increment,\n      decrement,\n      doubleCount // 可以在模板中使用\n    };\n  }\n};\n\u003c/script\u003e\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-8z1bl1e","Type":"NodeParagraph","Properties":{"id":"20250510111012-8z1bl1e","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在这个例子中，我们使用了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ref"},{"Type":"NodeText","Data":"​来创建了一个响应式的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"count"},{"Type":"NodeText","Data":"​变量，并定义了两个方法"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"increment"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"decrement"},{"Type":"NodeText","Data":"​来修改它的值。所有这些都被返回并暴露给了模板。"}]},{"ID":"20250510111012-nio2565","Type":"NodeParagraph","Properties":{"id":"20250510111012-nio2565","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"复用逻辑"},{"Type":"NodeText","Data":"：为了更好地理解逻辑复用的能力，考虑一个更复杂的场景，比如我们需要在多个组件中实现相同的计数器逻辑。我们可以将这部分逻辑提取到一个单独的函数中："}]},{"ID":"20250510111012-u3f7x4k","Type":"NodeParagraph","Properties":{"id":"20250510111012-u3f7x4k","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-ci2fblh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-ci2fblh","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// useCounter.js\nimport { ref } from 'vue';\n\nfunction useCounter(initialValue) {\n  const count = ref(initialValue);\n\n  const increment = () =\u003e { count.value++; };\n  const decrement = () =\u003e { count.value--; };\n\n  return { count, increment, decrement };\n}\n\nexport default useCounter;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-exi27ak","Type":"NodeParagraph","Properties":{"id":"20250510111012-exi27ak","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"然后，在任何需要的地方使用这个自定义hook："}]},{"ID":"20250510111012-4hshkah","Type":"NodeParagraph","Properties":{"id":"20250510111012-4hshkah","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"vue"}]},{"ID":"20250510111012-7wvr3n5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-7wvr3n5","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"\u003ctemplate\u003e\n  \u003cdiv\u003e\n    \u003cp\u003eCount: {{ count }}\u003c/p\u003e\n    \u003cbutton @click=\"increment\"\u003eIncrement\u003c/button\u003e\n    \u003cbutton @click=\"decrement\"\u003eDecrement\u003c/button\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cscript\u003e\nimport { defineComponent } from 'vue';\nimport useCounter from './useCounter';\n\nexport default defineComponent({\n  setup() {\n    const { count, increment, decrement } = useCounter(0);\n\n    return {\n      count,\n      increment,\n      decrement\n    };\n  }\n});\n\u003c/script\u003e\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-kageqey","Type":"NodeParagraph","Properties":{"id":"20250510111012-kageqey","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"这种方式不仅提高了代码的可读性和维护性，还促进了逻辑的复用，减少了重复代码。组合式API的强大之处在于它可以让你自由组合不同的逻辑块，适应各种复杂的应用需求。"}]},{"ID":"20250510111012-wkpws9w","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510111012-wkpws9w","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Class类 / Hooks / FP / 选项式API / 组合式API 的关系和区别"}]},{"ID":"20250510111012-5kc3t9f","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-5kc3t9f","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"概括"}]},{"ID":"20250510111012-2chg6rj","Type":"NodeParagraph","Properties":{"id":"20250510111012-2chg6rj","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"我们再对以上五个概念进行简单总结："}]},{"ID":"20250510111012-cjqxnk1","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-cjqxnk1","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Class类"}]},{"ID":"20250510111012-hpuhy46","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-hpuhy46","updated":"20250510111012"},"Children":[{"ID":"20250510111012-i5zz4kj","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-i5zz4kj","updated":"20250510111012"},"Children":[{"ID":"20250510111012-9zkzgxt","Type":"NodeParagraph","Properties":{"id":"20250510111012-9zkzgxt","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"定义"},{"Type":"NodeText","Data":"：在JavaScript中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"class"},{"Type":"NodeText","Data":"​提供了一种创建对象的模板，包括构造函数、方法和属性等。"}]}]},{"ID":"20250510111012-vy84ear","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-vy84ear","updated":"20250510111012"},"Children":[{"ID":"20250510111012-7ky8hba","Type":"NodeParagraph","Properties":{"id":"20250510111012-7ky8hba","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"用途"},{"Type":"NodeText","Data":"：主要用于面向对象编程（OOP），允许通过继承等方式实现代码复用。"}]}]},{"ID":"20250510111012-n44mjuo","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-n44mjuo","updated":"20250510111012"},"Children":[{"ID":"20250510111012-q3i434y","Type":"NodeParagraph","Properties":{"id":"20250510111012-q3i434y","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例框架"},{"Type":"NodeText","Data":"：React早期版本使用类组件来定义组件，并且Vue 2也支持使用类来创建组件。"}]}]}]},{"ID":"20250510111012-0sikp3n","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-0sikp3n","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Hooks"}]},{"ID":"20250510111012-hbfoq1u","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-hbfoq1u","updated":"20250510111012"},"Children":[{"ID":"20250510111012-0898w69","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-0898w69","updated":"20250510111012"},"Children":[{"ID":"20250510111012-02pam2m","Type":"NodeParagraph","Properties":{"id":"20250510111012-02pam2m","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"定义"},{"Type":"NodeText","Data":"：在React中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Hooks"},{"Type":"NodeText","Data":"​是一种特殊函数，允许你在不编写类的情况下使用状态和其他React特性。Vue中虽然没有直接称为“Hooks”的概念，但Vue 3中的自定义组合函数与之类似。"}]}]},{"ID":"20250510111012-6vskbwv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-6vskbwv","updated":"20250510111012"},"Children":[{"ID":"20250510111012-nyl1by7","Type":"NodeParagraph","Properties":{"id":"20250510111012-nyl1by7","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"用途"},{"Type":"NodeText","Data":"：简化状态管理和生命周期管理，使得逻辑复用更加方便。"}]}]},{"ID":"20250510111012-2txkjpw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-2txkjpw","updated":"20250510111012"},"Children":[{"ID":"20250510111012-hjp2ci9","Type":"NodeParagraph","Properties":{"id":"20250510111012-hjp2ci9","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例框架"},{"Type":"NodeText","Data":"：主要应用于React，但Vue 3的组合式API也支持类似的逻辑组织方式。"}]}]}]},{"ID":"20250510111012-k4jh2tm","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-k4jh2tm","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"函数式编程（FP）"}]},{"ID":"20250510111012-7oclqz5","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-7oclqz5","updated":"20250510111012"},"Children":[{"ID":"20250510111012-1dv9xcw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-1dv9xcw","updated":"20250510111012"},"Children":[{"ID":"20250510111012-3u5imqr","Type":"NodeParagraph","Properties":{"id":"20250510111012-3u5imqr","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"定义"},{"Type":"NodeText","Data":"：一种编程范式，强调使用纯函数、避免共享状态、可变数据和副作用。"}]}]},{"ID":"20250510111012-hrmrfw2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-hrmrfw2","updated":"20250510111012"},"Children":[{"ID":"20250510111012-9wu5phb","Type":"NodeParagraph","Properties":{"id":"20250510111012-9wu5phb","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"用途"},{"Type":"NodeText","Data":"：提高代码的清晰度、可测试性和可维护性。React和Vue 3都鼓励使用函数式编程的原则。"}]}]},{"ID":"20250510111012-g2evvcu","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-g2evvcu","updated":"20250510111012"},"Children":[{"ID":"20250510111012-39sv6r6","Type":"NodeParagraph","Properties":{"id":"20250510111012-39sv6r6","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例框架"},{"Type":"NodeText","Data":"：React通过Hooks促进了函数式编程风格；Vue 3则通过组合式API支持了更多的函数式编程实践。"}]}]}]},{"ID":"20250510111012-b6zou9o","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-b6zou9o","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"选项式API（Options API）"}]},{"ID":"20250510111012-c4kzomb","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-c4kzomb","updated":"20250510111012"},"Children":[{"ID":"20250510111012-escdje7","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-escdje7","updated":"20250510111012"},"Children":[{"ID":"20250510111012-vs6h15m","Type":"NodeParagraph","Properties":{"id":"20250510111012-vs6h15m","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"定义"},{"Type":"NodeText","Data":"：Vue.js的一种编程模式，通过将组件的不同部分（如data, methods, computed等）作为选项添加到一个对象中来定义组件。"}]}]},{"ID":"20250510111012-m2vl4jb","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-m2vl4jb","updated":"20250510111012"},"Children":[{"ID":"20250510111012-6ethriy","Type":"NodeParagraph","Properties":{"id":"20250510111012-6ethriy","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"用途"},{"Type":"NodeText","Data":"：提供了一种直观的方式来组织组件逻辑，特别适合初学者理解和使用。"}]}]},{"ID":"20250510111012-p9kmw4f","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-p9kmw4f","updated":"20250510111012"},"Children":[{"ID":"20250510111012-yd26qe6","Type":"NodeParagraph","Properties":{"id":"20250510111012-yd26qe6","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例框架"},{"Type":"NodeText","Data":"：主要应用于Vue 2及Vue 3中，用于构建Vue组件。"}]}]}]},{"ID":"20250510111012-q19krnc","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-q19krnc","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"组合式API（Composition API）"}]},{"ID":"20250510111012-jrgasrg","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-jrgasrg","updated":"20250510111012"},"Children":[{"ID":"20250510111012-tapcsx0","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-tapcsx0","updated":"20250510111012"},"Children":[{"ID":"20250510111012-5vcio1c","Type":"NodeParagraph","Properties":{"id":"20250510111012-5vcio1c","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"定义"},{"Type":"NodeText","Data":"：Vue 3引入的一种新的编程模式，允许开发者基于功能而非类型来组织代码，通常通过"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"setup"},{"Type":"NodeText","Data":"​函数实现。"}]}]},{"ID":"20250510111012-56smgx2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-56smgx2","updated":"20250510111012"},"Children":[{"ID":"20250510111012-analtcr","Type":"NodeParagraph","Properties":{"id":"20250510111012-analtcr","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"用途"},{"Type":"NodeText","Data":"：增强了代码的灵活性和复用性，特别是在处理复杂逻辑时表现尤为突出。"}]}]},{"ID":"20250510111012-1abafg7","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-1abafg7","updated":"20250510111012"},"Children":[{"ID":"20250510111012-ygwo10a","Type":"NodeParagraph","Properties":{"id":"20250510111012-ygwo10a","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例框架"},{"Type":"NodeText","Data":"：Vue 3中推荐的方式，也可以用于React中的某些高级场景（尽管React本身更倾向于使用Hooks）。"}]}]}]},{"ID":"20250510111012-xwqh1ck","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-xwqh1ck","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"关系和区别"}]},{"ID":"20250510111012-ygiule0","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-ygiule0","updated":"20250510111012"},"Children":[{"ID":"20250510111012-s9xr872","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-s9xr872","updated":"20250510111012"},"Children":[{"ID":"20250510111012-k0ghcdw","Type":"NodeParagraph","Properties":{"id":"20250510111012-k0ghcdw","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Class vs. 函数式编程"},{"Type":"NodeText","Data":"：Class是面向对象编程的核心，而函数式编程则追求无状态和不可变的数据流。两者代表了不同的编程哲学。"}]}]},{"ID":"20250510111012-w4hh00q","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-w4hh00q","updated":"20250510111012"},"Children":[{"ID":"20250510111012-6eb0dmn","Type":"NodeParagraph","Properties":{"id":"20250510111012-6eb0dmn","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Hooks vs. 组合式API"},{"Type":"NodeText","Data":"：虽然名称不同，但两者的目的相似，都是为了增强逻辑复用性和代码组织的灵活性。React的Hooks和Vue 3的组合式API都可以看作是函数式编程原则的应用。"}]}]},{"ID":"20250510111012-papuuqt","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-papuuqt","updated":"20250510111012"},"Children":[{"ID":"20250510111012-eh4m03j","Type":"NodeParagraph","Properties":{"id":"20250510111012-eh4m03j","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"选项式API vs. 组合式API"},{"Type":"NodeText","Data":"：选项式API按类型组织代码，而组合式API则允许你根据功能需求自由组合逻辑。后者提供了更大的灵活性，尤其是在处理复杂的业务逻辑时。"}]}]}]},{"ID":"20250510111012-1wak2td","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-1wak2td","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20250510111012-uckh2yp","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-uckh2yp","updated":"20250510111012"},"Children":[{"ID":"20250510111012-0q7g7gg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-0q7g7gg","updated":"20250510111012"},"Children":[{"ID":"20250510111012-lv63tf6","Type":"NodeParagraph","Properties":{"id":"20250510111012-lv63tf6","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Class类"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"函数式编程"},{"Type":"NodeText","Data":"代表了两种不同的编程范式，前者侧重于对象和类的关系，后者则强调纯函数和不可变数据。"}]}]},{"ID":"20250510111012-8i2vby0","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-8i2vby0","updated":"20250510111012"},"Children":[{"ID":"20250510111012-jzk44df","Type":"NodeParagraph","Properties":{"id":"20250510111012-jzk44df","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Hooks"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"组合式API"},{"Type":"NodeText","Data":"都是为了应对传统组件化开发中遇到的问题（如逻辑复用困难）而提出的解决方案，它们使代码更加模块化和易于维护。"}]}]},{"ID":"20250510111012-m89qowr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-m89qowr","updated":"20250510111012"},"Children":[{"ID":"20250510111012-8gwvhpp","Type":"NodeParagraph","Properties":{"id":"20250510111012-8gwvhpp","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"选项式API"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"组合式API"},{"Type":"NodeText","Data":"则是Vue框架内部提供的两种不同的编码风格，前者更适合初学者和小型项目，后者则为大型应用提供了更强的灵活性和扩展能力。"}]}]}]},{"ID":"20250510111012-n06syil","Type":"NodeParagraph","Properties":{"id":"20250510111012-n06syil","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"简单画张图表达他们的关系："}]},{"ID":"20250510111012-x1ne6dn","Type":"NodeParagraph","Properties":{"id":"20250510111012-x1ne6dn","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image-20250227172813931"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://www.helloimg.com/i/2025/02/27/67c0658c09d48.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250510111012-45dn390","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510111012-45dn390","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Mixins 混入"}]},{"ID":"20250510111012-z0qk60l","Type":"NodeParagraph","Properties":{"id":"20250510111012-z0qk60l","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"前端开发中，特别是在Vue.js框架里，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"mixins"},{"Type":"NodeText","Data":"（混入）是一种用于分发Vue组件可复用功能的灵活方式。Mixin本质上是一个包含部分选项的对象，这些选项可以被混入到其他组件中，从而让多个组件共享相同的逻辑或行为。通过这种方式，你可以避免重复代码，并促进代码的复用性。"}]},{"ID":"20250510111012-c260q2e","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-c260q2e","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"原理"}]},{"ID":"20250510111012-ziy1ecf","Type":"NodeParagraph","Properties":{"id":"20250510111012-ziy1ecf","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"当你将一个mixin对象传递给Vue组件时，该mixin中的选项会与组件自身的选项进行“合并”。对于大多数选项来说，如果组件和mixin都定义了相同的选项，它们的内容会被合并而不是覆盖。但是，对于某些特定选项（如生命周期钩子），mixin和组件的钩子都会被调用。"}]},{"ID":"20250510111012-w60yt0y","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-w60yt0y","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"示例"}]},{"ID":"20250510111012-x3orl7r","Type":"NodeParagraph","Properties":{"id":"20250510111012-x3orl7r","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"基本使用"},{"Type":"NodeText","Data":"：假设我们有一个需要在多个组件中使用的通用功能，比如获取当前时间并格式化显示"}]},{"ID":"20250510111012-js7s14i","Type":"NodeParagraph","Properties":{"id":"20250510111012-js7s14i","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"vue"}]},{"ID":"20250510111012-u27rxw6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-u27rxw6","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// 定义一个mixin\nconst datetimeMixin = {\n  data() {\n    return {\n      currentTime: new Date(),\n    };\n  },\n  methods: {\n    formatTime(date) {\n      const hours = date.getHours().toString().padStart(2, '0');\n      const minutes = date.getMinutes().toString().padStart(2, '0');\n      return `${hours}:${minutes}`;\n    }\n  },\n  mounted() {\n    setInterval(() =\u003e {\n      this.currentTime = new Date();\n    }, 1000);\n  }\n};\n\n// 使用mixin的组件\n\u003ctemplate\u003e\n  \u003cdiv\u003e\n    \u003cp\u003eCurrent Time: {{ formattedTime }}\u003c/p\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cscript\u003e\nexport default {\n  mixins: [datetimeMixin],\n  computed: {\n    formattedTime() {\n      return this.formatTime(this.currentTime);\n    }\n  }\n};\n\u003c/script\u003e\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-9s12wxr","Type":"NodeParagraph","Properties":{"id":"20250510111012-9s12wxr","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在这个例子中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"datetimeMixin"},{"Type":"NodeText","Data":"​提供了一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"currentTime"},{"Type":"NodeText","Data":"​的数据属性、一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"formatTime"},{"Type":"NodeText","Data":"​的方法以及一个定时更新当前时间的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mounted"},{"Type":"NodeText","Data":"​生命周期钩子。任何使用这个mixin的组件都可以直接访问这些属性和方法。"}]},{"ID":"20250510111012-i26ne0b","Type":"NodeParagraph","Properties":{"id":"20250510111012-i26ne0b","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"处理冲突"},{"Type":"NodeText","Data":"：当组件和mixin都定义了相同的选项时，Vue提供了默认的合并策略来处理这种情况。例如，对于methods、components和directives，它们会简单地合并成一个对象；如果有重复的名字，则组件的选项会覆盖mixin的选项。"}]},{"ID":"20250510111012-279w3l8","Type":"NodeParagraph","Properties":{"id":"20250510111012-279w3l8","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-d4mox9r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-d4mox9r","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// 定义两个mixin\nconst mixin1 = {\n  methods: {\n    sayHello() {\n      console.log('Hello from mixin1');\n    }\n  }\n};\n\nconst mixin2 = {\n  methods: {\n    sayHello() {\n      console.log('Hello from mixin2');\n    },\n    sayGoodbye() {\n      console.log('Goodbye from mixin2');\n    }\n  }\n};\n\n// 组件\nexport default {\n  mixins: [mixin1, mixin2],\n  created() {\n    this.sayHello(); // 输出 \"Hello from mixin2\"\n    this.sayGoodbye(); // 输出 \"Goodbye from mixin2\"\n  }\n};\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-9arldib","Type":"NodeParagraph","Properties":{"id":"20250510111012-9arldib","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在这个例子中，尽管"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mixin1"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mixin2"},{"Type":"NodeText","Data":"​都定义了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"sayHello"},{"Type":"NodeText","Data":"​方法，但最终调用的是来自"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mixin2"},{"Type":"NodeText","Data":"​的版本，因为后定义的mixin优先级更高。"}]},{"ID":"20250510111012-gy73um9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-gy73um9","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20250510111012-6bnxz77","Type":"NodeParagraph","Properties":{"id":"20250510111012-6bnxz77","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"虽然mixins是提高代码复用性的有力工具，但在使用时也需要注意一些潜在的问题："}]},{"ID":"20250510111012-cgvklwc","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-cgvklwc","updated":"20250510111012"},"Children":[{"ID":"20250510111012-ibj2eof","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-ibj2eof","updated":"20250510111012"},"Children":[{"ID":"20250510111012-lngk2bb","Type":"NodeParagraph","Properties":{"id":"20250510111012-lngk2bb","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"命名冲突"},{"Type":"NodeText","Data":"：如果不同的mixin定义了相同名称的选项或变量，可能会导致意外的行为。"}]}]},{"ID":"20250510111012-r2qffwe","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-r2qffwe","updated":"20250510111012"},"Children":[{"ID":"20250510111012-m5liimj","Type":"NodeParagraph","Properties":{"id":"20250510111012-m5liimj","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"复杂性增加"},{"Type":"NodeText","Data":"：过度使用mixins可能导致组件变得难以理解和维护，特别是当多个mixin相互依赖或重叠时。"}]}]},{"ID":"20250510111012-837xtyz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-837xtyz","updated":"20250510111012"},"Children":[{"ID":"20250510111012-nxrprrv","Type":"NodeParagraph","Properties":{"id":"20250510111012-nxrprrv","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"隐式依赖"},{"Type":"NodeText","Data":"：Mixins可能引入隐式的依赖关系，这使得追踪数据流变得更加困难。"}]}]}]},{"ID":"20250510111012-60u8hm8","Type":"NodeParagraph","Properties":{"id":"20250510111012-60u8hm8","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"因此，在设计你的应用架构时，应谨慎考虑是否采用mixins以及如何合理地组织它们。随着Vue 3的组合式API的普及，许多原本需要使用mixins实现的功能现在可以通过组合式API以更清晰的方式达成。"}]},{"ID":"20250510111012-198thkc","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510111012-198thkc","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Hooks 和 Mixins 的关系和区别"}]},{"ID":"20250510111012-rhhzm65","Type":"NodeParagraph","Properties":{"id":"20250510111012-rhhzm65","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mixins"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Hooks"},{"Type":"NodeText","Data":"​都是为了提高代码复用性和模块化而设计的机制，但它们在实现方式、使用场景以及设计理念上存在显著的不同。"}]},{"ID":"20250510111012-8h1my2m","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250510111012-8h1my2m","updated":"20250510111012"},"Children":[{"ID":"20250510111012-2rcz5n4","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250510111012-2rcz5n4","updated":"20250510111012"},"Children":[{"ID":"20250510111012-51sxwik","Type":"NodeParagraph","Properties":{"id":"20250510111012-51sxwik","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"设计理念"}]},{"ID":"20250510111012-amqekqj","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-amqekqj","updated":"20250510111012"},"Children":[{"ID":"20250510111012-bdjt0dd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-bdjt0dd","updated":"20250510111012"},"Children":[{"ID":"20250510111012-hgnd60x","Type":"NodeParagraph","Properties":{"id":"20250510111012-hgnd60x","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Mixins倾向于通过横向组合来扩展功能，即不同来源的功能片段被组合在一起形成完整的组件。"}]}]},{"ID":"20250510111012-9cl14o7","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-9cl14o7","updated":"20250510111012"},"Children":[{"ID":"20250510111012-hel34zg","Type":"NodeParagraph","Properties":{"id":"20250510111012-hel34zg","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Hooks则侧重于纵向切分，围绕特定功能（如状态管理、数据获取等）组织代码，使每个Hook专注于单一职责。"}]}]}]}]},{"ID":"20250510111012-iq9sc2d","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250510111012-iq9sc2d","updated":"20250510111012"},"Children":[{"ID":"20250510111012-vmubfbd","Type":"NodeParagraph","Properties":{"id":"20250510111012-vmubfbd","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"代码结构"}]},{"ID":"20250510111012-e19bf83","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-e19bf83","updated":"20250510111012"},"Children":[{"ID":"20250510111012-agvub3f","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-agvub3f","updated":"20250510111012"},"Children":[{"ID":"20250510111012-b2yt79j","Type":"NodeParagraph","Properties":{"id":"20250510111012-b2yt79j","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"使用Mixins时，可能会遇到命名冲突和难以追踪的数据流问题，尤其是在大型项目中。"}]}]},{"ID":"20250510111012-0xnqttf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-0xnqttf","updated":"20250510111012"},"Children":[{"ID":"20250510111012-wf00ti6","Type":"NodeParagraph","Properties":{"id":"20250510111012-wf00ti6","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Hooks通过显式的输入输出参数传递依赖关系，减少了意外副作用的可能性，同时保持了良好的局部性。"}]}]}]}]},{"ID":"20250510111012-72q1z4s","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250510111012-72q1z4s","updated":"20250510111012"},"Children":[{"ID":"20250510111012-hmk0kz5","Type":"NodeParagraph","Properties":{"id":"20250510111012-hmk0kz5","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"适用范围"}]},{"ID":"20250510111012-2kn45u2","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-2kn45u2","updated":"20250510111012"},"Children":[{"ID":"20250510111012-sl8t4wl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-sl8t4wl","updated":"20250510111012"},"Children":[{"ID":"20250510111012-vs4rkf7","Type":"NodeParagraph","Properties":{"id":"20250510111012-vs4rkf7","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Mixins适用于需要跨多个组件共享通用行为的情况，但在复杂场景下可能导致维护成本上升。"}]}]},{"ID":"20250510111012-50s1t34","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-50s1t34","updated":"20250510111012"},"Children":[{"ID":"20250510111012-zwuk9uw","Type":"NodeParagraph","Properties":{"id":"20250510111012-zwuk9uw","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Hooks更适合现代前端开发的趋势，尤其是对于追求高内聚低耦合的应用来说，Hooks提供了一种更加直观和灵活的方式来组织和重用逻辑。"}]}]}]}]},{"ID":"20250510111012-8k15xq7","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20250510111012-8k15xq7","updated":"20250510111012"},"Children":[{"ID":"20250510111012-5d0t539","Type":"NodeParagraph","Properties":{"id":"20250510111012-5d0t539","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"框架支持"}]},{"ID":"20250510111012-caalbw0","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-caalbw0","updated":"20250510111012"},"Children":[{"ID":"20250510111012-a3az8ne","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-a3az8ne","updated":"20250510111012"},"Children":[{"ID":"20250510111012-lmeu26k","Type":"NodeParagraph","Properties":{"id":"20250510111012-lmeu26k","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Mixins主要应用于Vue.js中，尽管在其他语言或框架中也有类似的概念。"}]}]},{"ID":"20250510111012-hdww478","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-hdww478","updated":"20250510111012"},"Children":[{"ID":"20250510111012-kw8owss","Type":"NodeParagraph","Properties":{"id":"20250510111012-kw8owss","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Hooks最初由React引入，随后影响到了Vue 3的设计，Vue 3的组合式API提供了类似于Hooks的功能，用于逻辑复用和组件构建。"}]}]}]}]}]},{"ID":"20250510111012-wnpfnmp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-wnpfnmp","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20250510111012-us2x21u","Type":"NodeParagraph","Properties":{"id":"20250510111012-us2x21u","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"总之，虽然Mixins和Hooks都能帮助开发者提高代码复用性，但Hooks因其更清晰的逻辑组织方式和更好的维护性，在现代前端开发中得到了更广泛的认可和支持。特别是在处理复杂的业务逻辑时，Hooks通常能提供更为简洁有效的解决方案。"}]},{"ID":"20250510111012-izua15m","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510111012-izua15m","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"生命周期 Lifecycle"}]},{"ID":"20250510111012-rnfs1hj","Type":"NodeParagraph","Properties":{"id":"20250510111012-rnfs1hj","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"在前端开发中，尤其是使用框架如 React 或 Vue 时，  "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"“生命周期” 指的是组件从创建到销毁的整个过程中的不同阶段"},{"Type":"NodeText","Data":"。每个阶段都有特定的钩子（Hooks）或方法，允许开发者执行特定的操作。理解这些生命周期概念对于有效地管理资源、优化性能和确保应用的行为符合预期至关重要。"}]},{"ID":"20250510111012-lfyy3am","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-lfyy3am","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"阶段"}]},{"ID":"20250510111012-vrertkd","Type":"NodeParagraph","Properties":{"id":"20250510111012-vrertkd","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"通常，一个组件的生命周期可以分为三个主要阶段：挂载（Mounting）、更新（Updating）和卸载（Unmounting）。"}]},{"ID":"20250510111012-4a0mwey","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-4a0mwey","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"示例"}]},{"ID":"20250510111012-063wmig","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-063wmig","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"React中的生命周期"}]},{"ID":"20250510111012-5ejhy8h","Type":"NodeParagraph","Properties":{"id":"20250510111012-5ejhy8h","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"挂载阶段 (Mounting)"},{"Type":"NodeText","Data":"  ："}]},{"ID":"20250510111012-1bpn08d","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-1bpn08d","updated":"20250510111012"},"Children":[{"ID":"20250510111012-w372xv4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-w372xv4","updated":"20250510111012"},"Children":[{"ID":"20250510111012-qd5et3x","Type":"NodeParagraph","Properties":{"id":"20250510111012-qd5et3x","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"当组件首次被插入到 DOM 中时会经历这个阶段。"}]}]},{"ID":"20250510111012-ww2vmhr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-ww2vmhr","updated":"20250510111012"},"Children":[{"ID":"20250510111012-tszzoh6","Type":"NodeParagraph","Properties":{"id":"20250510111012-tszzoh6","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"主要的生命周期方法包括 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"constructor()"},{"Type":"NodeText","Data":"​（类组件），"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"componentDidMount()"},{"Type":"NodeText","Data":"​（类组件），以及在函数组件中通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"useEffect"},{"Type":"NodeText","Data":"​ 钩子模拟。"}]}]},{"ID":"20250510111012-ivd6elx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-ivd6elx","updated":"20250510111012"},"Children":[{"ID":"20250510111012-uivvpih","Type":"NodeParagraph","Properties":{"id":"20250510111012-uivvpih","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"示例：在这个阶段，你可以发起网络请求获取数据，设置定时器等。"}]}]}]},{"ID":"20250510111012-63eqej0","Type":"NodeParagraph","Properties":{"id":"20250510111012-63eqej0","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"jsx"}]},{"ID":"20250510111012-uauzzog","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-uauzzog","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"useEffect(() =\u003e {\n  console.log('Component did mount');\n  return () =\u003e console.log('Cleanup on unmount'); // 清理副作用\n}, []); // 空数组意味着只在组件挂载和卸载时执行\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-lr4f93u","Type":"NodeParagraph","Properties":{"id":"20250510111012-lr4f93u","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"更新阶段 (Updating)"},{"Type":"NodeText","Data":"  ："}]},{"ID":"20250510111012-tdbtwjs","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-tdbtwjs","updated":"20250510111012"},"Children":[{"ID":"20250510111012-z1ju4mg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-z1ju4mg","updated":"20250510111012"},"Children":[{"ID":"20250510111012-r01qjtr","Type":"NodeParagraph","Properties":{"id":"20250510111012-r01qjtr","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"当组件的状态或属性发生变化时，会触发重新渲染，进入更新阶段。"}]}]},{"ID":"20250510111012-b5yyl59","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-b5yyl59","updated":"20250510111012"},"Children":[{"ID":"20250510111012-jx4xjk0","Type":"NodeParagraph","Properties":{"id":"20250510111012-jx4xjk0","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"包括 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"shouldComponentUpdate()"},{"Type":"NodeText","Data":"​（决定是否需要重新渲染），"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"render()"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"componentDidUpdate()"},{"Type":"NodeText","Data":"​（类组件），以及在函数组件中可以通过依赖项数组控制的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"useEffect"},{"Type":"NodeText","Data":"​ 来处理。"}]}]},{"ID":"20250510111012-0ggg6aw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-0ggg6aw","updated":"20250510111012"},"Children":[{"ID":"20250510111012-xrwcfth","Type":"NodeParagraph","Properties":{"id":"20250510111012-xrwcfth","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"示例：可以在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"componentDidUpdate"},{"Type":"NodeText","Data":"​ 中比较前后状态或属性的变化来进行特定操作。"}]}]}]},{"ID":"20250510111012-h1qhha7","Type":"NodeParagraph","Properties":{"id":"20250510111012-h1qhha7","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"jsx"}]},{"ID":"20250510111012-h4qjzjz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-h4qjzjz","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"useEffect(() =\u003e {\n  console.log('Component updated');\n}, [props.someProp]); // 只有当 someProp 改变时才会触发\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-a9ysuc6","Type":"NodeParagraph","Properties":{"id":"20250510111012-a9ysuc6","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"卸载阶段 (Unmounting)"},{"Type":"NodeText","Data":"  ："}]},{"ID":"20250510111012-09keuym","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-09keuym","updated":"20250510111012"},"Children":[{"ID":"20250510111012-2uxj54o","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-2uxj54o","updated":"20250510111012"},"Children":[{"ID":"20250510111012-vx522zj","Type":"NodeParagraph","Properties":{"id":"20250510111012-vx522zj","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"当组件从 DOM 中移除时，会调用卸载阶段的方法。"}]}]},{"ID":"20250510111012-5vcwmee","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-5vcwmee","updated":"20250510111012"},"Children":[{"ID":"20250510111012-01ja31t","Type":"NodeParagraph","Properties":{"id":"20250510111012-01ja31t","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"主要是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"componentWillUnmount()"},{"Type":"NodeText","Data":"​（类组件），或者在函数组件中通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"useEffect"},{"Type":"NodeText","Data":"​ 返回的清理函数实现。"}]}]},{"ID":"20250510111012-799j0ap","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-799j0ap","updated":"20250510111012"},"Children":[{"ID":"20250510111012-nsl2y1r","Type":"NodeParagraph","Properties":{"id":"20250510111012-nsl2y1r","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"示例：清除定时器、取消未完成的网络请求等。"}]}]}]},{"ID":"20250510111012-mrpngww","Type":"NodeParagraph","Properties":{"id":"20250510111012-mrpngww","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"jsx"}]},{"ID":"20250510111012-q8gnr48","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-q8gnr48","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"useEffect(() =\u003e {\n  const timer = setInterval(() =\u003e console.log('Tick'), 1000);\n  return () =\u003e clearInterval(timer); // 清理定时器\n}, []);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-apw1byn","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510111012-apw1byn","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"Vue 中的生命周期"}]},{"ID":"20250510111012-osx4pfd","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250510111012-osx4pfd","updated":"20250510111012"},"Children":[{"ID":"20250510111012-ilhuayz","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250510111012-ilhuayz","updated":"20250510111012"},"Children":[{"ID":"20250510111012-xwiempm","Type":"NodeParagraph","Properties":{"id":"20250510111012-xwiempm","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"挂载阶段"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510111012-plm1cqn","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-plm1cqn","updated":"20250510111012"},"Children":[{"ID":"20250510111012-stqda9x","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-stqda9x","updated":"20250510111012"},"Children":[{"ID":"20250510111012-d1yj2f0","Type":"NodeParagraph","Properties":{"id":"20250510111012-d1yj2f0","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"beforeCreate"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"created"},{"Type":"NodeText","Data":"​：实例初始化后和数据观测、事件等配置完成之前/之后。"}]}]},{"ID":"20250510111012-ugroc02","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-ugroc02","updated":"20250510111012"},"Children":[{"ID":"20250510111012-07tn7z3","Type":"NodeParagraph","Properties":{"id":"20250510111012-07tn7z3","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"beforeMount"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mounted"},{"Type":"NodeText","Data":"​：模板编译/虚拟DOM挂载到真实DOM前/后。"}]}]}]}]},{"ID":"20250510111012-icgfcc8","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250510111012-icgfcc8","updated":"20250510111012"},"Children":[{"ID":"20250510111012-778j6rb","Type":"NodeParagraph","Properties":{"id":"20250510111012-778j6rb","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"更新阶段"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510111012-8x2o206","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-8x2o206","updated":"20250510111012"},"Children":[{"ID":"20250510111012-jlfo23i","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-jlfo23i","updated":"20250510111012"},"Children":[{"ID":"20250510111012-9mpyshr","Type":"NodeParagraph","Properties":{"id":"20250510111012-9mpyshr","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"beforeUpdate"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"updated"},{"Type":"NodeText","Data":"​：当数据变化导致虚拟DOM重新渲染并在更新之前/之后触发。"}]}]}]}]},{"ID":"20250510111012-kjuaogn","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250510111012-kjuaogn","updated":"20250510111012"},"Children":[{"ID":"20250510111012-qjbrj4x","Type":"NodeParagraph","Properties":{"id":"20250510111012-qjbrj4x","updated":"20250510111012"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"卸载阶段"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510111012-dt9r16x","Type":"NodeList","ListData":{},"Properties":{"id":"20250510111012-dt9r16x","updated":"20250510111012"},"Children":[{"ID":"20250510111012-y58n51f","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510111012-y58n51f","updated":"20250510111012"},"Children":[{"ID":"20250510111012-olt7rsh","Type":"NodeParagraph","Properties":{"id":"20250510111012-olt7rsh","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"beforeDestroy"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"destroyed"},{"Type":"NodeText","Data":"​：实例销毁之前/之后，适合做清理工作。"}]}]}]}]}]},{"ID":"20250510111012-j9na465","Type":"NodeParagraph","Properties":{"id":"20250510111012-j9na465","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510111012-1b8wx84","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510111012-1b8wx84","updated":"20250510111012"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"export default {\n  mounted() {\n    console.log('Component has been mounted');\n  },\n  updated() {\n    console.log('Component has been updated');\n  },\n  beforeDestroy() {\n    console.log('Cleanup before component is destroyed');\n  }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510111012-h9hkg0r","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510111012-h9hkg0r","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20250510111012-lloveik","Type":"NodeParagraph","Properties":{"id":"20250510111012-lloveik","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"生命周期的概念帮助开发者更好地控制组件的行为，特别是在资源管理和状态同步方面。无论是 React 还是 Vue，了解并合理利用生命周期钩子都能极大地提升应用的质量和性能。例如，通过在适当的生命周期钩子中加载数据或释放资源，可以避免内存泄漏和其他潜在问题。"}]},{"ID":"20250510111012-rvo1sro","Type":"NodeParagraph","Properties":{"id":"20250510111012-rvo1sro","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"文章作者: "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://note.weizwz.com/","TextMarkTextContent":"weizwz"}]},{"ID":"20250510111012-cp8kxl7","Type":"NodeParagraph","Properties":{"id":"20250510111012-cp8kxl7","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"文章链接: "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://note.weizwz.com/terminology/design-paradigm","TextMarkTextContent":"https://note.weizwz.com/terminology/design-paradigm"}]},{"ID":"20250510111012-yzw1b3d","Type":"NodeParagraph","Properties":{"id":"20250510111012-yzw1b3d","updated":"20250510111012"},"Children":[{"Type":"NodeText","Data":"版权声明: 本站文章除特别声明外，均采用 "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh","TextMarkTextContent":"BY-NC-SA 4.0"},{"Type":"NodeText","Data":" 许可协议， 转载请注明来自 "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://note.weizwz.com/","TextMarkTextContent":"唯知笔记"},{"Type":"NodeText","Data":"！"}]}]}