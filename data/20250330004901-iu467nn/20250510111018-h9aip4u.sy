{"ID":"20250510111018-h9aip4u","Spec":"1","Type":"NodeDocument","Properties":{"id":"20250510111018-h9aip4u","title":"前端术语解读 - 编程思想类_conflict_github_1746846616393","type":"doc","updated":"20250510111018"},"Children":[{"ID":"20250510110940-eiyx2ya","Type":"NodeThematicBreak","Properties":{"id":"20250510110940-eiyx2ya","updated":"20250510110940"}},{"ID":"20250510110940-ufk7tge","Type":"NodeParagraph","Properties":{"id":"20250510110940-ufk7tge","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"title: 前端术语解读 - 编程思想类\ndate: 2025-03-30T00:51:36Z\nlastmod: 2025-03-30T00:52:07Z"}]},{"ID":"20250510110940-5stg8cj","Type":"NodeThematicBreak","Properties":{"id":"20250510110940-5stg8cj","updated":"20250510110940"}},{"ID":"20250510110940-706rvnz","Type":"NodeBlockquote","Properties":{"id":"20250510110940-706rvnz","updated":"20250510110940"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20250510110940-8jvn8oh","Type":"NodeParagraph","Properties":{"id":"20250510110940-8jvn8oh","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"前端名词解读，本篇是设计思想类。"}]}]},{"ID":"20250510110940-lrf351u","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510110940-lrf351u","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"OOP 面向对象编程"}]},{"ID":"20250510110940-ue7jybl","Type":"NodeParagraph","Properties":{"id":"20250510110940-ue7jybl","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"OOP是面向对象编程（Object-Oriented Programming）的缩写"},{"Type":"NodeText","Data":"。它是一种编程范式，通过“对象”来建模和解决问题，这些对象是类的实例。在前端开发中，OOP主要应用于JavaScript语言。但是需要注意JavaScript在技术上是一门多范式语言，不仅仅支持面向对象，也支持命令式以及函数式编程风格。"}]},{"ID":"20250510110940-6daklmb","Type":"NodeParagraph","Properties":{"id":"20250510110940-6daklmb","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在前端开发里使用OOP可以带来以下好处："}]},{"ID":"20250510110940-cptbjl8","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250510110940-cptbjl8","updated":"20250510110940"},"Children":[{"ID":"20250510110940-rn073q5","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250510110940-rn073q5","updated":"20250510110940"},"Children":[{"ID":"20250510110940-3v7r13k","Type":"NodeParagraph","Properties":{"id":"20250510110940-3v7r13k","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"代码组织"},{"Type":"NodeText","Data":"：通过将相关属性和方法封装到类中，可以使代码更加有组织性和可维护性；"}]}]},{"ID":"20250510110940-3b7u252","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250510110940-3b7u252","updated":"20250510110940"},"Children":[{"ID":"20250510110940-7d1y5yk","Type":"NodeParagraph","Properties":{"id":"20250510110940-7d1y5yk","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"代码重用"},{"Type":"NodeText","Data":"：继承机制允许一个类从另一个类那里继承属性和方法，减少了重复代码；"}]}]},{"ID":"20250510110940-rctym9j","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250510110940-rctym9j","updated":"20250510110940"},"Children":[{"ID":"20250510110940-z93plqp","Type":"NodeParagraph","Properties":{"id":"20250510110940-z93plqp","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"易于维护"},{"Type":"NodeText","Data":"：因为代码被分割成独立的对象，所以更容易进行调试和更新；"}]}]},{"ID":"20250510110940-351zhsv","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20250510110940-351zhsv","updated":"20250510110940"},"Children":[{"ID":"20250510110940-p9g16hk","Type":"NodeParagraph","Properties":{"id":"20250510110940-p9g16hk","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"抽象"},{"Type":"NodeText","Data":"：可以通过定义接口或者父类隐藏复杂的实现细节，只暴露必要的部分给使用者。"}]}]}]},{"ID":"20250510110940-8axwdu8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-8axwdu8","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"应用"}]},{"ID":"20250510110940-2jl9rl3","Type":"NodeParagraph","Properties":{"id":"20250510110940-2jl9rl3","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在现代JavaScript（ES6及以上版本）中，引入了class关键字来正式支持面向对象编程的概念，使得创建对象和实现继承变得更加直观和简单。例如："}]},{"ID":"20250510110940-blknams","Type":"NodeParagraph","Properties":{"id":"20250510110940-blknams","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-ccsu2l0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-ccsu2l0","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"dHM="},{"Type":"NodeCodeBlockCode","Data":"class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name);\n    this.breed = breed;\n  }\n\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\n\nlet d = new Dog('Mitzie', 'Dachshund');\nd.speak(); // 输出: Mitzie barks.\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-sdhvwor","Type":"NodeParagraph","Properties":{"id":"20250510110940-sdhvwor","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"这个例子展示了如何定义一个基类"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Animal"},{"Type":"NodeText","Data":"​和它的子类"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Dog"},{"Type":"NodeText","Data":"​，并通过"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"extends"},{"Type":"NodeText","Data":"​关键字实现继承，以及"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"super"},{"Type":"NodeText","Data":"​关键字调用父类的构造函数。"}]},{"ID":"20250510110940-q12ihb6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510110940-q12ihb6","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"MVC与MVVM"}]},{"ID":"20250510110940-oxz0ke1","Type":"NodeParagraph","Properties":{"id":"20250510110940-oxz0ke1","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在前端开发中，MVC 和 MVVM 是常见的设计模式，它们用于分离关注点，使得代码更加模块化、易于维护和扩展。"}]},{"ID":"20250510110940-04bxw9n","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-04bxw9n","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"MVC (Model-View-Controller)"}]},{"ID":"20250510110940-5aclswc","Type":"NodeParagraph","Properties":{"id":"20250510110940-5aclswc","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVC"},{"Type":"NodeText","Data":" 模式将应用程序分为三个核心组件："}]},{"ID":"20250510110940-1vi1mk1","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-1vi1mk1","updated":"20250510110940"},"Children":[{"ID":"20250510110940-21325bf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-21325bf","updated":"20250510110940"},"Children":[{"ID":"20250510110940-x7rx4s3","Type":"NodeParagraph","Properties":{"id":"20250510110940-x7rx4s3","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Model（模型）"},{"Type":"NodeText","Data":"  ：负责处理应用的数据逻辑，直接管理数据、逻辑和规则。"}]}]},{"ID":"20250510110940-px7cqz6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-px7cqz6","updated":"20250510110940"},"Children":[{"ID":"20250510110940-68td7kz","Type":"NodeParagraph","Properties":{"id":"20250510110940-68td7kz","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"View（视图）"},{"Type":"NodeText","Data":"  ：负责展示数据给用户，也就是UI部分。"}]}]},{"ID":"20250510110940-mqmlb1a","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-mqmlb1a","updated":"20250510110940"},"Children":[{"ID":"20250510110940-ulpyle5","Type":"NodeParagraph","Properties":{"id":"20250510110940-ulpyle5","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Controller（控制器）"},{"Type":"NodeText","Data":"  ：作为Model和View之间的桥梁，接收输入并转换它为命令发给Model或View。"}]}]}]},{"ID":"20250510110940-mz9h6fo","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-mz9h6fo","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"MVVM (Model-View-ViewModel)"}]},{"ID":"20250510110940-a7x3bvz","Type":"NodeParagraph","Properties":{"id":"20250510110940-a7x3bvz","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVVM"},{"Type":"NodeText","Data":" 是一种专门为简化用户界面的开发而设计的模式，它包括："}]},{"ID":"20250510110940-d21o1hz","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-d21o1hz","updated":"20250510110940"},"Children":[{"ID":"20250510110940-ezpxl7j","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-ezpxl7j","updated":"20250510110940"},"Children":[{"ID":"20250510110940-wfck5md","Type":"NodeParagraph","Properties":{"id":"20250510110940-wfck5md","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Model（模型）"},{"Type":"NodeText","Data":"  ：与MVC中的定义相同，处理业务逻辑和数据。"}]}]},{"ID":"20250510110940-gmlr9jw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-gmlr9jw","updated":"20250510110940"},"Children":[{"ID":"20250510110940-7h78sxe","Type":"NodeParagraph","Properties":{"id":"20250510110940-7h78sxe","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"View（视图）"},{"Type":"NodeText","Data":"  ：用户界面，负责显示数据。"}]}]},{"ID":"20250510110940-tmuzith","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-tmuzith","updated":"20250510110940"},"Children":[{"ID":"20250510110940-dwv8moi","Type":"NodeParagraph","Properties":{"id":"20250510110940-dwv8moi","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"ViewModel（视图模型）"},{"Type":"NodeText","Data":"  ：连接Model和View的部分，负责暴露数据对象以及在Model或者View发生变化时进行同步。"}]}]}]},{"ID":"20250510110940-68zlh0d","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-68zlh0d","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"应用"}]},{"ID":"20250510110940-pfsgxss","Type":"NodeParagraph","Properties":{"id":"20250510110940-pfsgxss","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"假设有一个简单的待办事项应用。当你添加一个新的待办事项时，输入会发送到Controller，Controller会通知Model更新数据，然后Model通知View刷新显示内容。"}]},{"ID":"20250510110940-escoz61","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-escoz61","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"MVC"}]},{"ID":"20250510110940-x808hua","Type":"NodeParagraph","Properties":{"id":"20250510110940-x808hua","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"模型负责处理应用的数据逻辑和规则"},{"Type":"NodeText","Data":"。在我们的待办事项应用中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TodoItem"},{"Type":"NodeText","Data":"​可以作为一个模型，它包含了待办事项的详细信息以及相关的业务逻辑。"}]},{"ID":"20250510110940-2hop17p","Type":"NodeParagraph","Properties":{"id":"20250510110940-2hop17p","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-2aln6f9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-2aln6f9","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"class TodoItem {\n    constructor(id, description) {\n        this.id = id;\n        this.description = description;\n        this.completed = false;\n    }\n\n    toggleCompleted() {\n        this.completed = !this.completed;\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-65n0535","Type":"NodeParagraph","Properties":{"id":"20250510110940-65n0535","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"视图负责呈现数据给用户，并且响应用户的交互"},{"Type":"NodeText","Data":"。在这个例子中，视图将展示待办事项列表，并提供添加新项目、完成项目的按钮等UI元素。"}]},{"ID":"20250510110940-1pbh3yt","Type":"NodeParagraph","Properties":{"id":"20250510110940-1pbh3yt","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"html"}]},{"ID":"20250510110940-ybctgph","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-ybctgph","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"\u003cdiv id=\"todo-app\"\u003e\n    \u003cul id=\"todo-list\"\u003e\u003c/ul\u003e\n    \u003cinput type=\"text\" id=\"new-todo\" placeholder=\"New todo\"\u003e\n    \u003cbutton id=\"add-todo\"\u003eAdd\u003c/button\u003e\n\u003c/div\u003e\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-gi2n1hf","Type":"NodeParagraph","Properties":{"id":"20250510110940-gi2n1hf","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"JavaScript部分可能如下："}]},{"ID":"20250510110940-676kh1i","Type":"NodeParagraph","Properties":{"id":"20250510110940-676kh1i","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-h3n6pdv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-h3n6pdv","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"function renderTodoList(todoItems) {\n    const todoListElement = document.getElementById('todo-list');\n    todoListElement.innerHTML = '';\n    todoItems.forEach(item =\u003e {\n        const li = document.createElement('li');\n        li.textContent = `${item.description} (${item.completed ? 'Completed' : 'Pending'})`;\n        todoListElement.appendChild(li);\n    });\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-vd842m8","Type":"NodeParagraph","Properties":{"id":"20250510110940-vd842m8","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"控制器是模型与视图之间的桥梁，它接收用户输入并更新模型或视图"},{"Type":"NodeText","Data":"。例如，当用户点击“Add”按钮时，控制器会获取输入框中的文本，创建一个新的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TodoItem"},{"Type":"NodeText","Data":"​实例，并更新视图以显示新的待办事项。"}]},{"ID":"20250510110940-ib8yl0b","Type":"NodeParagraph","Properties":{"id":"20250510110940-ib8yl0b","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-hz65lrh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-hz65lrh","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"document.getElementById('add-todo').addEventListener('click', () =\u003e {\n    const newTodoText = document.getElementById('new-todo').value;\n    if (newTodoText.trim()) {\n        const newItem = new TodoItem(Date.now(), newTodoText);\n        // 假设有一个方法可以添加新的待办事项到模型中\n        addTodoItem(newItem);\n        renderTodoList(getAllTodoItems());\n        document.getElementById('new-todo').value = '';\n    }\n});\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-p2qk21k","Type":"NodeParagraph","Properties":{"id":"20250510110940-p2qk21k","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"通过这个简单的例子，我们可以看到MVC模式是如何工作的："}]},{"ID":"20250510110940-61yiajq","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-61yiajq","updated":"20250510110940"},"Children":[{"ID":"20250510110940-wbcjsjk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-wbcjsjk","updated":"20250510110940"},"Children":[{"ID":"20250510110940-eooss1o","Type":"NodeParagraph","Properties":{"id":"20250510110940-eooss1o","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Model"},{"Type":"NodeText","Data":" ("},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TodoItem"},{"Type":"NodeText","Data":"​)：封装了待办事项的数据和行为。"}]}]},{"ID":"20250510110940-jw953xe","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-jw953xe","updated":"20250510110940"},"Children":[{"ID":"20250510110940-9ks4zeh","Type":"NodeParagraph","Properties":{"id":"20250510110940-9ks4zeh","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"View"},{"Type":"NodeText","Data":" (HTML + 渲染逻辑)：展示了待办事项列表，并提供了用户交互的界面。"}]}]},{"ID":"20250510110940-0175378","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-0175378","updated":"20250510110940"},"Children":[{"ID":"20250510110940-zr6v5f9","Type":"NodeParagraph","Properties":{"id":"20250510110940-zr6v5f9","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Controller"},{"Type":"NodeText","Data":" (事件监听器)：处理用户输入（如点击按钮），并根据输入更新模型或视图。"}]}]}]},{"ID":"20250510110940-7euegow","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-7euegow","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"MVVM"}]},{"ID":"20250510110940-isoe6ln","Type":"NodeParagraph","Properties":{"id":"20250510110940-isoe6ln","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"继续以待办事项应用为例，在MVVM架构下，你可能会使用像Vue.js这样的框架。ViewModel通过双向绑定机制自动同步Model和View之间的数据。当用户在View中更改待办事项的状态时，这些更改会自动反映在Model中，反之亦然。"}]},{"ID":"20250510110940-o8ioahx","Type":"NodeParagraph","Properties":{"id":"20250510110940-o8ioahx","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-lwxmczv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-lwxmczv","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// 简化的Vue示例代码\nnew Vue({\n  el: '#app',\n  data: {\n    todos: [\n      { text: '学习JavaScript', done: false },\n      { text: '学习Vue', done: false }\n    ]\n  },\n  methods: {\n    addTodo: function() {\n      this.todos.push({ text: this.newTodoText, done: false });\n      this.newTodoText = '';\n    }\n  }\n});\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-xe3f6xc","Type":"NodeParagraph","Properties":{"id":"20250510110940-xe3f6xc","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在这个简化的Vue.js示例中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"data"},{"Type":"NodeText","Data":"​属性充当了Model的角色，模板（HTML部分）是View，而Vue实例本身扮演着ViewModel的角色，负责管理数据和逻辑，并确保它们能正确地映射到View上。这样，开发者可以专注于数据和业务逻辑，而不必手动操作DOM来更新界面。"}]},{"ID":"20250510110940-4pttoam","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-4pttoam","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"区别"}]},{"ID":"20250510110940-tbuzwyf","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250510110940-tbuzwyf","updated":"20250510110940"},"Children":[{"ID":"20250510110940-iwndc0m","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250510110940-iwndc0m","updated":"20250510110940"},"Children":[{"ID":"20250510110940-j9x9abt","Type":"NodeParagraph","Properties":{"id":"20250510110940-j9x9abt","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"数据绑定机制"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510110940-3xcusmu","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-3xcusmu","updated":"20250510110940"},"Children":[{"ID":"20250510110940-iw49nju","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-iw49nju","updated":"20250510110940"},"Children":[{"ID":"20250510110940-wozg5td","Type":"NodeParagraph","Properties":{"id":"20250510110940-wozg5td","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVC"},{"Type":"NodeText","Data":"：通常依赖于手动的数据同步。控制器负责从模型获取数据，并更新视图，反之亦然。这通常需要编写额外的代码来保持视图和模型之间的一致性。"}]}]},{"ID":"20250510110940-tzsl6gp","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-tzsl6gp","updated":"20250510110940"},"Children":[{"ID":"20250510110940-96gf14b","Type":"NodeParagraph","Properties":{"id":"20250510110940-96gf14b","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVVM"},{"Type":"NodeText","Data":"：通过双向数据绑定自动同步视图(View)和视图模型(ViewModel)。这意味着当视图中的数据发生变化时，这些变化会自动反映在视图模型中，反之亦然，无需开发者手动进行数据同步。"}]}]}]}]},{"ID":"20250510110940-6r51hdd","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250510110940-6r51hdd","updated":"20250510110940"},"Children":[{"ID":"20250510110940-d68ozq9","Type":"NodeParagraph","Properties":{"id":"20250510110940-d68ozq9","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"角色职责"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510110940-mni2ez0","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-mni2ez0","updated":"20250510110940"},"Children":[{"ID":"20250510110940-bqjc21u","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-bqjc21u","updated":"20250510110940"},"Children":[{"ID":"20250510110940-3xd1dlo","Type":"NodeParagraph","Properties":{"id":"20250510110940-3xd1dlo","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVC"},{"Type":"NodeText","Data":"：控制器(Controller)作为中介者，接收用户输入并调用模型(Model)或视图(View)的方法来处理业务逻辑或更新界面。"}]}]},{"ID":"20250510110940-nnxzeud","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-nnxzeud","updated":"20250510110940"},"Children":[{"ID":"20250510110940-towya2h","Type":"NodeParagraph","Properties":{"id":"20250510110940-towya2h","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVVM"},{"Type":"NodeText","Data":"：视图模型(ViewModel)不仅充当了MVC中控制器的角色，还包含了视图的状态和行为逻辑。ViewModel是专门为视图准备的数据模型，它不直接引用视图，而是通过数据绑定与视图交互。"}]}]}]}]},{"ID":"20250510110940-d0dzd2x","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250510110940-d0dzd2x","updated":"20250510110940"},"Children":[{"ID":"20250510110940-dyepen4","Type":"NodeParagraph","Properties":{"id":"20250510110940-dyepen4","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"测试友好性"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510110940-2p5e3kw","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-2p5e3kw","updated":"20250510110940"},"Children":[{"ID":"20250510110940-s8jnu19","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-s8jnu19","updated":"20250510110940"},"Children":[{"ID":"20250510110940-q0icbn3","Type":"NodeParagraph","Properties":{"id":"20250510110940-q0icbn3","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVC"},{"Type":"NodeText","Data":"：由于控制器直接处理用户输入并控制应用流程，可能需要模拟HTTP请求等环境来进行单元测试，增加了测试复杂度。"}]}]},{"ID":"20250510110940-8tkr8zw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-8tkr8zw","updated":"20250510110940"},"Children":[{"ID":"20250510110940-f2l9l4s","Type":"NodeParagraph","Properties":{"id":"20250510110940-f2l9l4s","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVVM"},{"Type":"NodeText","Data":"：由于ViewModel不依赖于具体的UI技术，更容易进行单元测试。你可以单独对ViewModel进行测试，而不需要考虑视图的具体实现。"}]}]}]}]},{"ID":"20250510110940-x26ssi0","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20250510110940-x26ssi0","updated":"20250510110940"},"Children":[{"ID":"20250510110940-qvgb7j9","Type":"NodeParagraph","Properties":{"id":"20250510110940-qvgb7j9","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"使用场景"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510110940-3ytce8f","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-3ytce8f","updated":"20250510110940"},"Children":[{"ID":"20250510110940-4bbsyz5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-4bbsyz5","updated":"20250510110940"},"Children":[{"ID":"20250510110940-jm1gnxa","Type":"NodeParagraph","Properties":{"id":"20250510110940-jm1gnxa","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVC"},{"Type":"NodeText","Data":"：适用于传统的Web应用程序，尤其是那些后端渲染页面较多的应用。"}]}]},{"ID":"20250510110940-r1klw83","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-r1klw83","updated":"20250510110940"},"Children":[{"ID":"20250510110940-e780y7f","Type":"NodeParagraph","Properties":{"id":"20250510110940-e780y7f","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"MVVM"},{"Type":"NodeText","Data":"：特别适合现代单页应用(SPA)，其中前端负责大部分的用户交互逻辑。Vue.js、Angular等框架都采用了MVVM模式。"}]}]}]}]}]},{"ID":"20250510110940-hs8wl78","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510110940-hs8wl78","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Duck Typing 鸭子类型"}]},{"ID":"20250510110940-h9p3at3","Type":"NodeParagraph","Properties":{"id":"20250510110940-h9p3at3","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"鸭子类型（Duck Typing）是动态类型语言中的一种概念，主要体现在对对象的行为的关注而非其具体的类型"},{"Type":"NodeText","Data":"。这一概念源于詹姆斯·惠特科姆·赖利的一句谚语：“如果它走起来像鸭子，叫起来像鸭子，那么它就是鸭子。”在编程领域，这意味着只要一个对象实现了所需的方法和属性，即使该对象不属于某个特定的类或接口，也能被视为某种类型并正常使用。"}]},{"ID":"20250510110940-k7cpmij","Type":"NodeParagraph","Properties":{"id":"20250510110940-k7cpmij","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"由于JavaScript 是一门动态类型语言，天然支持这种编程风格，所以在前端开发中广泛的使用鸭子类型（Duck Typing）。"}]},{"ID":"20250510110940-pnoh49s","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-pnoh49s","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"特点"}]},{"ID":"20250510110940-0cq9kfj","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250510110940-0cq9kfj","updated":"20250510110940"},"Children":[{"ID":"20250510110940-qeq4z9h","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250510110940-qeq4z9h","updated":"20250510110940"},"Children":[{"ID":"20250510110940-xenrldm","Type":"NodeParagraph","Properties":{"id":"20250510110940-xenrldm","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"核心思想"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510110940-88zl6al","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-88zl6al","updated":"20250510110940"},"Children":[{"ID":"20250510110940-p5og4dp","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-p5og4dp","updated":"20250510110940"},"Children":[{"ID":"20250510110940-purm3d1","Type":"NodeParagraph","Properties":{"id":"20250510110940-purm3d1","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"行为优先"},{"Type":"NodeText","Data":"：鸭子类型关注对象能否完成某项任务，而不关心对象的具体类型。"}]}]},{"ID":"20250510110940-4lx6vrc","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-4lx6vrc","updated":"20250510110940"},"Children":[{"ID":"20250510110940-tz4957r","Type":"NodeParagraph","Properties":{"id":"20250510110940-tz4957r","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"动态绑定"},{"Type":"NodeText","Data":"：由于动态类型的特点，对象的类型在运行时才确定，因此可以通过方法的存在与否来进行类型验证。"}]}]}]}]},{"ID":"20250510110940-wgvvud0","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250510110940-wgvvud0","updated":"20250510110940"},"Children":[{"ID":"20250510110940-p0v10ml","Type":"NodeParagraph","Properties":{"id":"20250510110940-p0v10ml","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"优点"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510110940-rp9kwab","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-rp9kwab","updated":"20250510110940"},"Children":[{"ID":"20250510110940-o2e9cx6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-o2e9cx6","updated":"20250510110940"},"Children":[{"ID":"20250510110940-c3y8xms","Type":"NodeParagraph","Properties":{"id":"20250510110940-c3y8xms","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"灵活性高"},{"Type":"NodeText","Data":"：减少了代码间的耦合，提高了代码的重用性和适应性。"}]}]},{"ID":"20250510110940-l7ioi6j","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-l7ioi6j","updated":"20250510110940"},"Children":[{"ID":"20250510110940-b56na3w","Type":"NodeParagraph","Properties":{"id":"20250510110940-b56na3w","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"简化开发流程"},{"Type":"NodeText","Data":"：开发者不必担心严格的类型约束，可以根据需求快速实现新功能。"}]}]}]}]},{"ID":"20250510110940-ulrn10w","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250510110940-ulrn10w","updated":"20250510110940"},"Children":[{"ID":"20250510110940-4m7fdw6","Type":"NodeParagraph","Properties":{"id":"20250510110940-4m7fdw6","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"缺点"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510110940-t67npc7","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-t67npc7","updated":"20250510110940"},"Children":[{"ID":"20250510110940-x5zow95","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-x5zow95","updated":"20250510110940"},"Children":[{"ID":"20250510110940-b878vej","Type":"NodeParagraph","Properties":{"id":"20250510110940-b878vej","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"缺乏明确性"},{"Type":"NodeText","Data":"：可能导致代码难以理解和调试，因为缺少显式的类型信息。"}]}]},{"ID":"20250510110940-tgaewkb","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-tgaewkb","updated":"20250510110940"},"Children":[{"ID":"20250510110940-989s4zd","Type":"NodeParagraph","Properties":{"id":"20250510110940-989s4zd","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"潜在的风险"},{"Type":"NodeText","Data":"：如果没有正确处理缺失的方法，可能会导致运行时错误。"}]}]}]}]}]},{"ID":"20250510110940-41k67m8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-41k67m8","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"应用"}]},{"ID":"20250510110940-mxmp2e1","Type":"NodeParagraph","Properties":{"id":"20250510110940-mxmp2e1","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"通用事件处理器"}]},{"ID":"20250510110940-2m9ed1r","Type":"NodeParagraph","Properties":{"id":"20250510110940-2m9ed1r","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-gwsq46d","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-gwsq46d","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// 假设我们有两个对象，一个是按钮，另一个是链接\nconst button = {\n    click: () =\u003e console.log('Button clicked!')\n};\n\nconst link = {\n    click: () =\u003e console.log('Link clicked!')\n};\n\n// 定义一个通用的点击处理器函数\nfunction handleClick(element) {\n    if (typeof element.click === 'function') {\n        element.click();\n    } else {\n        console.error('Element does not have a click method.');\n    }\n}\n\nhandleClick(button); // 输出: Button clicked!\nhandleClick(link);   // 输出: Link clicked!\n\n// 另外一个不符合条件的对象\nconst div = {};\nhandleClick(div);      // 输出: Element does not have a click method.\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-im12yop","Type":"NodeParagraph","Properties":{"id":"20250510110940-im12yop","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在这个例子中，handleClick 函数并不关心 element 的具体类型，只需要知道它有没有 click 方法即可。这种方式使得代码更具灵活性和可扩展性。"}]},{"ID":"20250510110940-lf547nf","Type":"NodeParagraph","Properties":{"id":"20250510110940-lf547nf","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"插件化架构"}]},{"ID":"20250510110940-c5op66t","Type":"NodeParagraph","Properties":{"id":"20250510110940-c5op66t","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在一些框架中，如 React 插件或 Vue 组件库，鸭子类型可以帮助实现高度模块化的代码结构。"}]},{"ID":"20250510110940-95pi3lb","Type":"NodeParagraph","Properties":{"id":"20250510110940-95pi3lb","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-zajg422","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-zajg422","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"import React from 'react';\n\n// 定义一个通用的渲染函数\nfunction renderComponent(componentInstance) {\n    if (componentInstance.render \u0026\u0026 typeof componentInstance.render === 'function') {\n        return \u003cdiv\u003e{componentInstance.render()}\u003c/div\u003e;\n    } else {\n        throw new Error('Invalid component instance');\n    }\n}\n\n// 实现第一个组件\nclass MyFirstComponent extends React.Component {\n    render() {\n        return \u003cp\u003eThis is the first component.\u003c/p\u003e;\n    }\n}\n\n// 实现第二个组件\nclass MySecondComponent extends React.Component {\n    render() {\n        return \u003cp\u003eThis is the second component.\u003c/p\u003e;\n    }\n}\n\n// 使用渲染函数\nfunction App() {\n    const components = [\n        new MyFirstComponent(),\n        new MySecondComponent()\n    ];\n\n    return (\n        \u003cdiv\u003e\n            {components.map((comp, index) =\u003e (\n                \u003cdiv key={index}\u003e{renderComponent(comp)}\u003c/div\u003e\n            ))}\n        \u003c/div\u003e\n    );\n}\n\nexport default App;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-kmdrvl3","Type":"NodeParagraph","Properties":{"id":"20250510110940-kmdrvl3","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在这个例子中，renderComponent 函数只关心传入的对象是否有 render 方法，而不限制具体的类名或其他细节。这使得你可以轻松地添加新的组件，只要它们实现了 render 方法即可。"}]},{"ID":"20250510110940-okphxsb","Type":"NodeParagraph","Properties":{"id":"20250510110940-okphxsb","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"配置选项"}]},{"ID":"20250510110940-k7atkx4","Type":"NodeParagraph","Properties":{"id":"20250510110940-k7atkx4","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在许多 JavaScript 库中，配置选项通常是通过对象字面量传递的，这些对象可以有不同的形状，但只要包含所需的键值对即可。"}]},{"ID":"20250510110940-qzzgb1v","Type":"NodeParagraph","Properties":{"id":"20250510110940-qzzgb1v","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-md3znh4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-md3znh4","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// 定义一个初始化函数\nfunction initialize(options) {\n    if (options.start \u0026\u0026 typeof options.start === 'function') {\n        options.start();\n    }\n\n    if (options.end \u0026\u0026 typeof options.end === 'function') {\n        options.end();\n    }\n\n    if (options.duration !== undefined \u0026\u0026 !isNaN(options.duration)) {\n        setTimeout(() =\u003e {\n            if (options.complete \u0026\u0026 typeof options.complete === 'function') {\n                options.complete();\n            }\n        }, options.duration);\n    }\n}\n\n// 初始化带有 start 和 end 回调的动画\ninitialize({\n    start: () =\u003e console.log('Animation started'),\n    end: () =\u003e console.log('Animation ended'),\n    duration: 1000\n});\n\n// 初始化只有 complete 回调的动画\ninitialize({\n    complete: () =\u003e console.log('Animation completed without explicit start and end')\n});\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-34p96uz","Type":"NodeParagraph","Properties":{"id":"20250510110940-34p96uz","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在这个例子中，initialize 函数根据提供的 options 对象的不同属性来执行相应的操作。只要 options 包含所需的方法或属性，就不必遵循固定的类层次结构。"}]},{"ID":"20250510110940-jc7uwvw","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510110940-jc7uwvw","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Mutable/Immutable Data 可变/不可变 数据"}]},{"ID":"20250510110940-9b1fee5","Type":"NodeParagraph","Properties":{"id":"20250510110940-9b1fee5","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在编程中，  "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"\u0026quot;mutable\u0026quot;（可变的）指的是对象在其创建后可以被改变或修改"},{"Type":"NodeText","Data":"。相反的，  "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"\u0026quot;immutable\u0026quot;（不可变的）指的是对象一旦创建之后就不能再被修改"},{"Type":"NodeText","Data":"。在前端开发中，特别是在使用JavaScript这样的语言时，理解可变性和不可变性是非常重要的，因为这会影响到代码的行为、性能以及维护性。"}]},{"ID":"20250510110940-4udkc8p","Type":"NodeParagraph","Properties":{"id":"20250510110940-4udkc8p","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在前端开发中，尤其是在React等框架中提倡使用不可变数据结构来管理组件的状态。这样做可以帮助开发者更容易地理解和跟踪状态的变化，减少由于状态意外变更引起的bug，并简化调试过程。此外，利用不可变数据结构还可以优化应用的性能，比如通过浅比较（shallow comparison）快速判断前后状态是否发生变化，从而决定是否需要重新渲染组件。"}]},{"ID":"20250510110940-nzat1wn","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-nzat1wn","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"示例"}]},{"ID":"20250510110940-m172ks6","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-m172ks6","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"可变数据（Mutable Data）"}]},{"ID":"20250510110940-frd1y9g","Type":"NodeParagraph","Properties":{"id":"20250510110940-frd1y9g","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"当你处理的是可变数据时，你可以直接修改数据而不需要创建新的数据结构。例如，在JavaScript中，数组和对象都是默认可变的："}]},{"ID":"20250510110940-tu56coc","Type":"NodeParagraph","Properties":{"id":"20250510110940-tu56coc","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-419yab0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-419yab0","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"let arr = [1, 2, 3];\narr.push(4); // 直接修改了原数组\nconsole.log(arr); // 输出 [1, 2, 3, 4]\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-83gb0f9","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-83gb0f9","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"不可变数据（Immutable Data）"}]},{"ID":"20250510110940-mi81pgr","Type":"NodeParagraph","Properties":{"id":"20250510110940-mi81pgr","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"与之相对，不可变数据意味着任何“修改”都会产生一个新的数据结构，而原始数据不会被改变。这种方法有助于避免副作用，并且使得追踪状态变化更加容易。在JavaScript中实现不可变数据结构通常需要手动复制原有数据结构并进行修改，或者使用专门的库如Immutable.js。"}]},{"ID":"20250510110940-3l7kpse","Type":"NodeParagraph","Properties":{"id":"20250510110940-3l7kpse","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-lb3n9bh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-lb3n9bh","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"const arr = [1, 2, 3];\nconst newArr = [...arr, 4]; // 创建一个新数组而不是修改原有的\nconsole.log(arr); // 输出 [1, 2, 3]\nconsole.log(newArr); // 输出 [1, 2, 3, 4]\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-3qux5ss","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510110940-3qux5ss","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Class 类"}]},{"ID":"20250510110940-rf335u3","Type":"NodeParagraph","Properties":{"id":"20250510110940-rf335u3","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在现代JavaScript（ES6及以后版本）中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"class"},{"Type":"NodeText","Data":"​提供了一种定义对象蓝图的清晰且简洁的语法。虽然JavaScript中的类本质上是基于原型的继承的一种语法糖，但它们使得面向对象编程的概念如类、构造函数、继承等更加直观和易于理解。"}]},{"ID":"20250510110940-r9gyuhz","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-r9gyuhz","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"基本概念"}]},{"ID":"20250510110940-kecamzy","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-kecamzy","updated":"20250510110940"},"Children":[{"ID":"20250510110940-u0iaoac","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-u0iaoac","updated":"20250510110940"},"Children":[{"ID":"20250510110940-kg3fwu1","Type":"NodeParagraph","Properties":{"id":"20250510110940-kg3fwu1","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"类（Class）"},{"Type":"NodeText","Data":"  ：定义了如何创建一个对象的类型。它包含了属性（数据成员）和方法（成员函数）。"}]}]},{"ID":"20250510110940-livqt3v","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-livqt3v","updated":"20250510110940"},"Children":[{"ID":"20250510110940-j2mqbn6","Type":"NodeParagraph","Properties":{"id":"20250510110940-j2mqbn6","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"构造函数（Constructor）"},{"Type":"NodeText","Data":"  ：特殊的方法用于创建和初始化类的一个实例对象。在类中定义时使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"constructor"},{"Type":"NodeText","Data":"​关键字。"}]}]},{"ID":"20250510110940-9s7xwkr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-9s7xwkr","updated":"20250510110940"},"Children":[{"ID":"20250510110940-5uti8uo","Type":"NodeParagraph","Properties":{"id":"20250510110940-5uti8uo","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"继承（Inheritance）"},{"Type":"NodeText","Data":"  ：允许一个类继承另一个类的特征，这有助于代码重用和建立类之间的关系。"}]}]},{"ID":"20250510110940-zsfv04z","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-zsfv04z","updated":"20250510110940"},"Children":[{"ID":"20250510110940-sdgstsx","Type":"NodeParagraph","Properties":{"id":"20250510110940-sdgstsx","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"方法（Methods）"},{"Type":"NodeText","Data":"  ：定义在类内部的函数，描述了该类的对象可以执行的行为。"}]}]}]},{"ID":"20250510110940-7lualjf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-7lualjf","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"示例"}]},{"ID":"20250510110940-mzybuok","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-mzybuok","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"定义类"}]},{"ID":"20250510110940-8jvf32s","Type":"NodeParagraph","Properties":{"id":"20250510110940-8jvf32s","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-mlocq1x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-mlocq1x","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"class Rectangle {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n    }\n\n    getArea() {\n        return this.width * this.height;\n    }\n\n    getPerimeter() {\n        return 2 * (this.width + this.height);\n    }\n}\n\nconst myRectangle = new Rectangle(10, 20);\nconsole.log(myRectangle.getArea()); // 输出: 200\nconsole.log(myRectangle.getPerimeter()); // 输出: 60\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-2ccyla9","Type":"NodeParagraph","Properties":{"id":"20250510110940-2ccyla9","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在这个例子中，我们定义了一个名为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rectangle"},{"Type":"NodeText","Data":"​的类，它有两个属性："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"width"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"height"},{"Type":"NodeText","Data":"​，以及两个方法："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"getArea"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"getPerimeter"},{"Type":"NodeText","Data":"​。通过"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"new Rectangle(10, 20)"},{"Type":"NodeText","Data":"​创建了一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rectangle"},{"Type":"NodeText","Data":"​类的实例，并调用了它的方法来获取面积和周长。"}]},{"ID":"20250510110940-0mxvk26","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-0mxvk26","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"继承"}]},{"ID":"20250510110940-fh0vlxk","Type":"NodeParagraph","Properties":{"id":"20250510110940-fh0vlxk","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"我们可以从一个已有的类派生出新的类，新类将自动获得父类的所有属性和方法，并可以添加或覆盖这些特性。"}]},{"ID":"20250510110940-x6lye3l","Type":"NodeParagraph","Properties":{"id":"20250510110940-x6lye3l","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-7a1rusj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-7a1rusj","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"class Square extends Rectangle {\n    constructor(sideLength) {\n        super(sideLength, sideLength); // 调用父类的构造函数\n    }\n\n    // 可以添加或覆盖方法\n    isSquare() {\n        return true; // 对于正方形总是返回true\n    }\n}\n\nconst mySquare = new Square(15);\nconsole.log(mySquare.getArea()); // 输出: 225\nconsole.log(mySquare.isSquare()); // 输出: true\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-fyovl3p","Type":"NodeParagraph","Properties":{"id":"20250510110940-fyovl3p","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"这里，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Square"},{"Type":"NodeText","Data":"​类继承自"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rectangle"},{"Type":"NodeText","Data":"​类，因此它可以访问"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rectangle"},{"Type":"NodeText","Data":"​的所有方法。此外，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Square"},{"Type":"NodeText","Data":"​还定义了自己的方法"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"isSquare"},{"Type":"NodeText","Data":"​，表明任何"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Square"},{"Type":"NodeText","Data":"​实例都是正方形。"}]},{"ID":"20250510110940-azeaeva","Type":"NodeParagraph","Properties":{"id":"20250510110940-azeaeva","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"通过这种方式，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"class"},{"Type":"NodeText","Data":"​关键字使得JavaScript中的面向对象编程更加直观和高效，支持了诸如封装、继承等重要概念，同时也简化了代码结构。"}]},{"ID":"20250510110940-mql3izf","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510110940-mql3izf","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"FP 函数式编程"}]},{"ID":"20250510110940-0v6v6bk","Type":"NodeParagraph","Properties":{"id":"20250510110940-0v6v6bk","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"函数式编程（Functional Programming）是一种编程范式，它将计算视为数学函数的求值，避免了改变状态和可变数据"},{"Type":"NodeText","Data":"。函数式编程鼓励使用纯函数、高阶函数以及不可变数据结构等概念，使得代码更加简洁、易于理解和测试。"}]},{"ID":"20250510110940-frpjo01","Type":"NodeParagraph","Properties":{"id":"20250510110940-frpjo01","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在 JavaScript 这样的语言中，由于其天生支持闭包和高阶函数等特性，函数式编程变得非常流行。利用函数式编程的思想，可以帮助开发者写出更加模块化、更具有复用性的代码，同时也能够提高代码的可靠性和开发效率。流行的前端框架和库，如 React 或者 lodash 等，都或多或少地采用了函数式编程的概念。"}]},{"ID":"20250510110940-weqplke","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-weqplke","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"示例"}]},{"ID":"20250510110940-80di5lp","Type":"NodeParagraph","Properties":{"id":"20250510110940-80di5lp","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"假设我们有一个数组，里面包含了一些用户的对象，每个对象都有一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"age"},{"Type":"NodeText","Data":"​ 属性表示用户的年龄。我们的目标是过滤出所有成年人（年龄大于等于18岁），然后创建一个新的数组，其中只包含这些成年人的名字。"}]},{"ID":"20250510110940-k4cjtcq","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-k4cjtcq","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"非函数式编程"}]},{"ID":"20250510110940-mcig0g5","Type":"NodeParagraph","Properties":{"id":"20250510110940-mcig0g5","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-4arxc4e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-4arxc4e","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"let users = [\n  { name: \"Alice\", age: 25 },\n  { name: \"Bob\", age: 17 },\n  { name: \"Carol\", age: 30 }\n];\n\nlet adultNames = [];\nfor (let i = 0; i \u003c users.length; i++) {\n  if (users[i].age \u003e= 18) {\n    adultNames.push(users[i].name);\n  }\n}\nconsole.log(adultNames); // 输出 [\"Alice\", \"Carol\"]\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-7b8bgok","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-7b8bgok","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"函数式编程"}]},{"ID":"20250510110940-rvz7zhj","Type":"NodeParagraph","Properties":{"id":"20250510110940-rvz7zhj","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"使用函数式编程的思想，我们可以利用 JavaScript 的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"filter"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​ 方法来更简洁地完成同样的任务。"}]},{"ID":"20250510110940-tg9jv7l","Type":"NodeParagraph","Properties":{"id":"20250510110940-tg9jv7l","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-t4h320k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-t4h320k","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"const users = [\n  { name: \"Alice\", age: 25 },\n  { name: \"Bob\", age: 17 },\n  { name: \"Carol\", age: 30 }\n];\n\nconst adultNames = users\n  .filter(user =\u003e user.age \u003e= 18) // 过滤出年龄大于等于18的用户\n  .map(user =\u003e user.name); // 将过滤后的用户对象转换为名字\n\nconsole.log(adultNames); // 输出 [\"Alice\", \"Carol\"]\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-1wcjk4k","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510110940-1wcjk4k","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Hooks 钩子"}]},{"ID":"20250510110940-nzh7pjj","Type":"NodeParagraph","Properties":{"id":"20250510110940-nzh7pjj","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在前端开发中，“Hooks” 概念最先由 React 提出。"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Hooks允许函数组件拥有状态和生命周期方法等类组件的特性，而无需编写类"},{"Type":"NodeText","Data":"。它们使得代码更加简洁、易于理解和测试。"}]},{"ID":"20250510110940-wloh687","Type":"NodeParagraph","Properties":{"id":"20250510110940-wloh687","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"从更广泛的角度来看，  "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"“Hook”可以被理解为一种设计模式或机制，它允许函数或模块之间以一种更加动态和灵活的方式进行交互"},{"Type":"NodeText","Data":"。具体来说，Hook通常指的是一个函数，该函数可以在不修改原始代码的情况下扩展或改变某些行为。这种模式不仅限于React框架，实际上，在其他编程环境和语言中也有类似的概念。"}]},{"ID":"20250510110940-rqqrxf5","Type":"NodeParagraph","Properties":{"id":"20250510110940-rqqrxf5","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在React中，Hooks 存在以下基本概念"}]},{"ID":"20250510110940-syk5an4","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-syk5an4","updated":"20250510110940"},"Children":[{"ID":"20250510110940-fbm2ie7","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-fbm2ie7","updated":"20250510110940"},"Children":[{"ID":"20250510110940-y31sbdh","Type":"NodeParagraph","Properties":{"id":"20250510110940-y31sbdh","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"State Hook"},{"Type":"NodeText","Data":"：使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"useState"},{"Type":"NodeText","Data":"​来为函数组件添加状态。"}]}]},{"ID":"20250510110940-8jjdm3w","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-8jjdm3w","updated":"20250510110940"},"Children":[{"ID":"20250510110940-b38ezyn","Type":"NodeParagraph","Properties":{"id":"20250510110940-b38ezyn","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Effect Hook"},{"Type":"NodeText","Data":"：使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"useEffect"},{"Type":"NodeText","Data":"​来执行副作用操作，如数据获取、订阅或手动DOM更新等。"}]}]},{"ID":"20250510110940-e5u7pa2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-e5u7pa2","updated":"20250510110940"},"Children":[{"ID":"20250510110940-dqvy78j","Type":"NodeParagraph","Properties":{"id":"20250510110940-dqvy78j","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"自定义Hooks"},{"Type":"NodeText","Data":"：封装可复用的逻辑，便于在多个组件间共享功能。"}]}]}]},{"ID":"20250510110940-98r741w","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-98r741w","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"示例"}]},{"ID":"20250510110940-ry81a3w","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-ry81a3w","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在React中的 Hooks"}]},{"ID":"20250510110940-jva1a1c","Type":"NodeParagraph","Properties":{"id":"20250510110940-jva1a1c","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"State Hook"},{"Type":"NodeText","Data":"：下面的例子展示了如何使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"useState"},{"Type":"NodeText","Data":"​ 来管理一个计数器的状态："}]},{"ID":"20250510110940-i5gor7w","Type":"NodeParagraph","Properties":{"id":"20250510110940-i5gor7w","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-yjecv1g","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-yjecv1g","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"import React, { useState } from 'react';\n\nfunction Counter() {\n    // 使用useState初始化状态，count是当前状态，setCount是更新状态的函数\n    const [count, setCount] = useState(0);\n\n    return (\n        \u003cdiv\u003e\n            \u003cp\u003eYou clicked {count} times\u003c/p\u003e\n            \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e\n                Click me\n            \u003c/button\u003e\n        \u003c/div\u003e\n    );\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-ywn9lyk","Type":"NodeParagraph","Properties":{"id":"20250510110940-ywn9lyk","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Effect Hook"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"useEffect"},{"Type":"NodeText","Data":"​ 可以用来处理组件的副作用，比如加载数据或设置订阅等。下面的例子展示了一个组件在挂载时获取数据并在卸载时清理副作用的操作："}]},{"ID":"20250510110940-89m7iq1","Type":"NodeParagraph","Properties":{"id":"20250510110940-89m7iq1","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-m0r7syz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-m0r7syz","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"import React, { useState, useEffect } from 'react';\n\nfunction FriendStatus(props) {\n    const [isOnline, setIsOnline] = useState(null);\n\n    useEffect(() =\u003e {\n        function handleStatusChange(status) {\n            setIsOnline(status.isOnline);\n        }\n\n        // 模拟订阅好友状态\n        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n        // 清理副作用\n        return () =\u003e {\n            ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n        };\n    }, [props.friend.id]); // 只有当friend.id改变时才重新执行effect\n\n    if (isOnline === null) {\n        return 'Loading...';\n    }\n    return isOnline ? 'Online' : 'Offline';\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-4llgam0","Type":"NodeParagraph","Properties":{"id":"20250510110940-4llgam0","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在这个例子中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"useEffect"},{"Type":"NodeText","Data":"​用于模拟监听朋友在线状态的变化，并且在组件卸载时取消了这个监听，避免了潜在的内存泄漏问题。"}]},{"ID":"20250510110940-fgpu7nj","Type":"NodeParagraph","Properties":{"id":"20250510110940-fgpu7nj","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"自定义Hooks"},{"Type":"NodeText","Data":"：自定义Hooks让我们可以从不同的组件中提取组件逻辑到可重用的函数中。例如，我们可以创建一个自定义Hook来简化上述检查好友状态的功能："}]},{"ID":"20250510110940-yarvfxd","Type":"NodeParagraph","Properties":{"id":"20250510110940-yarvfxd","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-3dhvhl2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-3dhvhl2","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"function useFriendStatus(friendID) {\n    const [isOnline, setIsOnline] = useState(null);\n\n    useEffect(() =\u003e {\n        function handleStatusChange(status) {\n            setIsOnline(status.isOnline);\n        }\n\n        ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\n        return () =\u003e {\n            ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\n        };\n    }, [friendID]);\n\n    return isOnline;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-wc8w250","Type":"NodeParagraph","Properties":{"id":"20250510110940-wc8w250","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"然后，在其他组件中可以这样使用这个自定义Hook："}]},{"ID":"20250510110940-md48b0l","Type":"NodeParagraph","Properties":{"id":"20250510110940-md48b0l","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-vs3w2fd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-vs3w2fd","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"function FriendStatusWithCustomHook(props) {\n    const isOnline = useFriendStatus(props.friend.id);\n\n    if (isOnline === null) {\n        return 'Loading...';\n    }\n    return isOnline ? 'Online' : 'Offline';\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-1loadkg","Type":"NodeParagraph","Properties":{"id":"20250510110940-1loadkg","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"通过这种方式，Hooks不仅简化了React组件的编写方式，还提高了代码的复用性和可读性。"}]},{"ID":"20250510110940-j32lh3b","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-j32lh3b","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"非React环境中的Hooks"}]},{"ID":"20250510110940-djsyym2","Type":"NodeParagraph","Properties":{"id":"20250510110940-djsyym2","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"脱离React来讨论Hooks，我们可以从以下几个方面来理解："}]},{"ID":"20250510110940-7ducbxp","Type":"NodeParagraph","Properties":{"id":"20250510110940-7ducbxp","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"插件系统或扩展点"},{"Type":"NodeText","Data":"： 在许多应用程序或框架中，开发者可以通过定义特定的“钩子”（hooks）或者回调函数来扩展默认行为。例如，在Web开发中，Express.js中间件机制就可以看作是一种Hook实现方式。你可以通过添加中间件来处理请求之前或之后的行为。"}]},{"ID":"20250510110940-j46o7yu","Type":"NodeParagraph","Properties":{"id":"20250510110940-j46o7yu","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-zu01als","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-zu01als","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"const express = require('express');\nconst app = express();\n\n// 这里的中间件就是一个hook的例子\napp.use((req, res, next) =\u003e {\n    console.log('Request received');\n    next(); // 调用下一个中间件或路由处理器\n});\n\napp.get('/', (req, res) =\u003e {\n    res.send('Hello World!');\n});\n\napp.listen(3000, () =\u003e console.log('Server started'));\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-q32bmtp","Type":"NodeParagraph","Properties":{"id":"20250510110940-q32bmtp","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"事件监听器"},{"Type":"NodeText","Data":"： 在JavaScript中，事件驱动编程也是利用了类似的Hook概念。比如，DOM事件监听器允许你在特定事件发生时执行自定义逻辑。"}]},{"ID":"20250510110940-99yassq","Type":"NodeParagraph","Properties":{"id":"20250510110940-99yassq","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-n4hqnsb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-n4hqnsb","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"document.getElementById('myButton').addEventListener('click', function(event) {\n    console.log('Button clicked');\n});\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-216fwli","Type":"NodeParagraph","Properties":{"id":"20250510110940-216fwli","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"生命周期回调"},{"Type":"NodeText","Data":"： 在Node.js中，某些模块提供了生命周期钩子，允许你在特定时刻插入自己的逻辑。例如，Mocha测试框架允许你定义"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"beforeEach"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"afterEach"},{"Type":"NodeText","Data":"​等钩子来设置测试环境或清理资源。"}]},{"ID":"20250510110940-t5muw8b","Type":"NodeParagraph","Properties":{"id":"20250510110940-t5muw8b","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-z44rxm9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-z44rxm9","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"describe('Array', function() {\n  beforeEach(function() {\n    this.arr = [1, 2, 3];\n  });\n\n  it('should contain 3 elements', function() {\n    assert.equal(this.arr.length, 3);\n  });\n});\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-m7l8fov","Type":"NodeParagraph","Properties":{"id":"20250510110940-m7l8fov","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"自定义Hook"},{"Type":"NodeText","Data":"： 在非React环境中，我们也可以创建自己的Hook来复用逻辑。比如，我们可以创建一个通用的日志记录Hook来统一管理日志输出。"}]},{"ID":"20250510110940-7jtj060","Type":"NodeParagraph","Properties":{"id":"20250510110940-7jtj060","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-2nkboye","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-2nkboye","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"function useLogger(prefix) {\n    return function log(message) {\n        console.log(`[${prefix}] ${message}`);\n    };\n}\n\nconst logger = useLogger('INFO');\nlogger('This is a log message');\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-d2ifweb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-d2ifweb","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20250510110940-h3zh2uy","Type":"NodeParagraph","Properties":{"id":"20250510110940-h3zh2uy","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"总的来说，无论是React中的Hooks还是其他环境下的类似概念，它们的核心思想都是提供一种机制，让开发者能够在不修改原有代码的基础上，通过预定义的“入口点”或“钩子”来注入额外的功能或逻辑。这种方式有助于提高代码的模块化程度、可维护性和复用性。因此，虽然React将“Hooks”这一概念推广开来，但实际上，这种模式在软件开发中有更广泛的应用。"}]},{"ID":"20250510110940-4jrv0f9","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510110940-4jrv0f9","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Options API 选项式API"}]},{"ID":"20250510110940-27pp80b","Type":"NodeParagraph","Properties":{"id":"20250510110940-27pp80b","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"选项式API（Options API）是Vue.js早期版本中用于组织组件逻辑的主要方式，特别是在Vue 2中得到了广泛应用，并在Vue 3中继续得到支持。它"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"通过将组件的不同特性（如数据、计算属性、方法、生命周期钩子等）分门别类地定义在一个对象的各个选项中来构建Vue组件"},{"Type":"NodeText","Data":"。"}]},{"ID":"20250510110940-1wkesp0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-1wkesp0","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"核心"}]},{"ID":"20250510110940-7yxpfx7","Type":"NodeParagraph","Properties":{"id":"20250510110940-7yxpfx7","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"选项式API的核心在于它 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"提供了一种结构化的方式来定义组件的不同方面，每个方面都对应于组件对象的一个属性"},{"Type":"NodeText","Data":"。这种方式使得代码看起来非常直观和有条理，尤其适合初学者理解和使用。"}]},{"ID":"20250510110940-wnodyci","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-wnodyci","updated":"20250510110940"},"Children":[{"ID":"20250510110940-nryddpv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-nryddpv","updated":"20250510110940"},"Children":[{"ID":"20250510110940-iotjvtn","Type":"NodeParagraph","Properties":{"id":"20250510110940-iotjvtn","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"data"},{"Type":"NodeText","Data":"：定义组件的状态（即响应式数据）。可以是一个函数（在Vue 2中对于单文件组件必须是函数，在Vue 3中对于所有组件都是函数），该函数返回一个包含状态的对象。"}]}]},{"ID":"20250510110940-b06if79","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-b06if79","updated":"20250510110940"},"Children":[{"ID":"20250510110940-ghyxnl8","Type":"NodeParagraph","Properties":{"id":"20250510110940-ghyxnl8","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"methods"},{"Type":"NodeText","Data":"：定义组件内使用的函数，这些函数可以改变组件的状态或触发其他操作。"}]}]},{"ID":"20250510110940-276yjhc","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-276yjhc","updated":"20250510110940"},"Children":[{"ID":"20250510110940-pry9iu4","Type":"NodeParagraph","Properties":{"id":"20250510110940-pry9iu4","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"computed"},{"Type":"NodeText","Data":"：定义计算属性，这些属性基于其他数据进行计算，且只有当依赖的数据发生变化时才会重新计算。"}]}]},{"ID":"20250510110940-k001j1h","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-k001j1h","updated":"20250510110940"},"Children":[{"ID":"20250510110940-ory0noe","Type":"NodeParagraph","Properties":{"id":"20250510110940-ory0noe","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"watch"},{"Type":"NodeText","Data":"：监听特定数据的变化，并在数据变化时执行相应的回调函数。"}]}]},{"ID":"20250510110940-gshzzjr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-gshzzjr","updated":"20250510110940"},"Children":[{"ID":"20250510110940-2nfhhkw","Type":"NodeParagraph","Properties":{"id":"20250510110940-2nfhhkw","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"生命周期钩子"},{"Type":"NodeText","Data":"：例如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"created"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mounted"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"updated"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"beforeDestroy"},{"Type":"NodeText","Data":"​等，允许你在组件生命周期的不同阶段执行自定义逻辑。"}]}]}]},{"ID":"20250510110940-uhj2ai4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-uhj2ai4","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"示例"}]},{"ID":"20250510110940-e7ve2fq","Type":"NodeParagraph","Properties":{"id":"20250510110940-e7ve2fq","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"vue"}]},{"ID":"20250510110940-kdtv0rs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-kdtv0rs","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"\u003ctemplate\u003e\n  \u003cdiv\u003e\n    \u003cp\u003eCount: {{ count }}\u003c/p\u003e\n    \u003cbutton @click=\"increment\"\u003eIncrement\u003c/button\u003e\n    \u003cp\u003eDouble Count: {{ doubleCount }}\u003c/p\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cscript\u003e\nexport default {\n  // 定义组件的状态\n  data() {\n    return {\n      count: 0,\n    };\n  },\n  // 计算属性\n  computed: {\n    doubleCount() {\n      return this.count * 2;\n    },\n  },\n  // 方法\n  methods: {\n    increment() {\n      this.count++;\n    },\n  },\n  // 生命周期钩子\n  mounted() {\n    console.log('Component has been mounted.');\n  },\n};\n\u003c/script\u003e\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-6h1tzjt","Type":"NodeParagraph","Properties":{"id":"20250510110940-6h1tzjt","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在这个例子中："}]},{"ID":"20250510110940-zr7qcpg","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-zr7qcpg","updated":"20250510110940"},"Children":[{"ID":"20250510110940-u8uf6n3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-u8uf6n3","updated":"20250510110940"},"Children":[{"ID":"20250510110940-xe0yifh","Type":"NodeParagraph","Properties":{"id":"20250510110940-xe0yifh","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"data"},{"Type":"NodeText","Data":"：初始化了一个名为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"count"},{"Type":"NodeText","Data":"​的状态变量。"}]}]},{"ID":"20250510110940-upqru2g","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-upqru2g","updated":"20250510110940"},"Children":[{"ID":"20250510110940-z4kd5l5","Type":"NodeParagraph","Properties":{"id":"20250510110940-z4kd5l5","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"computed"},{"Type":"NodeText","Data":"：定义了一个计算属性"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"doubleCount"},{"Type":"NodeText","Data":"​，它基于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"count"},{"Type":"NodeText","Data":"​值进行计算。"}]}]},{"ID":"20250510110940-tub6gfv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-tub6gfv","updated":"20250510110940"},"Children":[{"ID":"20250510110940-rjmgovs","Type":"NodeParagraph","Properties":{"id":"20250510110940-rjmgovs","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"methods"},{"Type":"NodeText","Data":"：定义了一个名为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"increment"},{"Type":"NodeText","Data":"​的方法，用于增加"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"count"},{"Type":"NodeText","Data":"​的值。"}]}]},{"ID":"20250510110940-klwx6u4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-klwx6u4","updated":"20250510110940"},"Children":[{"ID":"20250510110940-q2i2nbn","Type":"NodeParagraph","Properties":{"id":"20250510110940-q2i2nbn","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"mounted"},{"Type":"NodeText","Data":"：生命周期钩子，当组件挂载到DOM后会自动调用，这里用来打印一条消息到控制台。"}]}]}]},{"ID":"20250510110940-esk17fm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510110940-esk17fm","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Composition API 组合式API"}]},{"ID":"20250510110940-fiqs2pd","Type":"NodeParagraph","Properties":{"id":"20250510110940-fiqs2pd","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Vue 3引入的组合式API（Composition API）是一种新的组织和复用逻辑的方式，它为开发者提供了更大的灵活性来构建Vue组件。与选项式API（Options API）不同，组合式API允许你基于功能而非类型来组织代码。"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件"},{"Type":"NodeText","Data":"。"}]},{"ID":"20250510110940-784qzbd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-784qzbd","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"核心"}]},{"ID":"20250510110940-l9nbr2z","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250510110940-l9nbr2z","updated":"20250510110940"},"Children":[{"ID":"20250510110940-0b35eif","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250510110940-0b35eif","updated":"20250510110940"},"Children":[{"ID":"20250510110940-6l2jk0n","Type":"NodeParagraph","Properties":{"id":"20250510110940-6l2jk0n","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"setup函数"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510110940-ekj8jf8","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-ekj8jf8","updated":"20250510110940"},"Children":[{"ID":"20250510110940-mdoszb6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-mdoszb6","updated":"20250510110940"},"Children":[{"ID":"20250510110940-buv71ve","Type":"NodeParagraph","Properties":{"id":"20250510110940-buv71ve","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在Vue 3中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"setup"},{"Type":"NodeText","Data":"​函数是使用组合式API的入口点。它在组件创建之前执行，并返回一个对象，该对象中的属性将暴露给模板和其他选项。"}]}]}]}]},{"ID":"20250510110940-xvt3iu0","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250510110940-xvt3iu0","updated":"20250510110940"},"Children":[{"ID":"20250510110940-kagxqrl","Type":"NodeParagraph","Properties":{"id":"20250510110940-kagxqrl","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"响应式数据"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510110940-ucg8ddu","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-ucg8ddu","updated":"20250510110940"},"Children":[{"ID":"20250510110940-8yeek4v","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-8yeek4v","updated":"20250510110940"},"Children":[{"ID":"20250510110940-88ermj1","Type":"NodeParagraph","Properties":{"id":"20250510110940-88ermj1","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Vue 3提供了一系列用于创建响应式数据的方法，如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ref"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"reactive"},{"Type":"NodeText","Data":"​。这些方法使得你可以轻松地创建能够自动追踪更新的数据源。"}]}]}]}]},{"ID":"20250510110940-yt3hc8s","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250510110940-yt3hc8s","updated":"20250510110940"},"Children":[{"ID":"20250510110940-cv82oxe","Type":"NodeParagraph","Properties":{"id":"20250510110940-cv82oxe","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"生命周期钩子"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510110940-eq9txv8","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-eq9txv8","updated":"20250510110940"},"Children":[{"ID":"20250510110940-mhvqsyd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-mhvqsyd","updated":"20250510110940"},"Children":[{"ID":"20250510110940-uprooyz","Type":"NodeParagraph","Properties":{"id":"20250510110940-uprooyz","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"组合式API提供了与Vue 2相似的生命周期钩子，但它们以函数的形式存在，例如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"onMounted"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"onUpdated"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"onUnmounted"},{"Type":"NodeText","Data":"​等。"}]}]}]}]},{"ID":"20250510110940-8dvnjpx","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20250510110940-8dvnjpx","updated":"20250510110940"},"Children":[{"ID":"20250510110940-kn7tmef","Type":"NodeParagraph","Properties":{"id":"20250510110940-kn7tmef","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"计算属性和监听器"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510110940-e6wktnf","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-e6wktnf","updated":"20250510110940"},"Children":[{"ID":"20250510110940-2rx2xcs","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-2rx2xcs","updated":"20250510110940"},"Children":[{"ID":"20250510110940-78paw0b","Type":"NodeParagraph","Properties":{"id":"20250510110940-78paw0b","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"computed"},{"Type":"NodeText","Data":"​可以创建计算属性，它会根据其依赖项自动更新。使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"watch"},{"Type":"NodeText","Data":"​可以监听特定数据的变化，并在变化时执行副作用操作。"}]}]}]}]},{"ID":"20250510110940-ctdoqfj","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20250510110940-ctdoqfj","updated":"20250510110940"},"Children":[{"ID":"20250510110940-yd2pmcm","Type":"NodeParagraph","Properties":{"id":"20250510110940-yd2pmcm","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"自定义逻辑复用"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510110940-yphsf4v","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-yphsf4v","updated":"20250510110940"},"Children":[{"ID":"20250510110940-ozdympx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-ozdympx","updated":"20250510110940"},"Children":[{"ID":"20250510110940-9rxm3gf","Type":"NodeParagraph","Properties":{"id":"20250510110940-9rxm3gf","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"通过将相关逻辑封装到可复用的函数中，组合式API使得逻辑复用变得非常简单。这些函数通常被称为“hooks”，尽管Vue 3本身并没有直接使用这个术语。"}]}]}]}]}]},{"ID":"20250510110940-dzrsmt4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-dzrsmt4","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"示例"}]},{"ID":"20250510110940-or3mfq3","Type":"NodeParagraph","Properties":{"id":"20250510110940-or3mfq3","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"简单计数器"}]},{"ID":"20250510110940-5g984su","Type":"NodeParagraph","Properties":{"id":"20250510110940-5g984su","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"vue"}]},{"ID":"20250510110940-9ial4j1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-9ial4j1","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"\u003ctemplate\u003e\n  \u003cdiv\u003e\n    \u003cp\u003eCount: {{ count }}\u003c/p\u003e\n    \u003cbutton @click=\"increment\"\u003eIncrement\u003c/button\u003e\n    \u003cbutton @click=\"decrement\"\u003eDecrement\u003c/button\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cscript\u003e\nimport { ref, computed } from 'vue';\n\nexport default {\n  setup() {\n    // 创建响应式状态\n    const count = ref(0);\n\n    // 定义修改状态的方法\n    const increment = () =\u003e { count.value++; };\n    const decrement = () =\u003e { count.value--; };\n\n    // 可选：创建计算属性\n    const doubleCount = computed(() =\u003e count.value * 2);\n\n    return {\n      count,\n      increment,\n      decrement,\n      doubleCount // 可以在模板中使用\n    };\n  }\n};\n\u003c/script\u003e\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-52f0kap","Type":"NodeParagraph","Properties":{"id":"20250510110940-52f0kap","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在这个例子中，我们使用了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ref"},{"Type":"NodeText","Data":"​来创建了一个响应式的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"count"},{"Type":"NodeText","Data":"​变量，并定义了两个方法"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"increment"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"decrement"},{"Type":"NodeText","Data":"​来修改它的值。所有这些都被返回并暴露给了模板。"}]},{"ID":"20250510110940-aoasouk","Type":"NodeParagraph","Properties":{"id":"20250510110940-aoasouk","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"复用逻辑"},{"Type":"NodeText","Data":"：为了更好地理解逻辑复用的能力，考虑一个更复杂的场景，比如我们需要在多个组件中实现相同的计数器逻辑。我们可以将这部分逻辑提取到一个单独的函数中："}]},{"ID":"20250510110940-omy64su","Type":"NodeParagraph","Properties":{"id":"20250510110940-omy64su","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-gq0uflj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-gq0uflj","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// useCounter.js\nimport { ref } from 'vue';\n\nfunction useCounter(initialValue) {\n  const count = ref(initialValue);\n\n  const increment = () =\u003e { count.value++; };\n  const decrement = () =\u003e { count.value--; };\n\n  return { count, increment, decrement };\n}\n\nexport default useCounter;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-x17z9lq","Type":"NodeParagraph","Properties":{"id":"20250510110940-x17z9lq","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"然后，在任何需要的地方使用这个自定义hook："}]},{"ID":"20250510110940-q0padi3","Type":"NodeParagraph","Properties":{"id":"20250510110940-q0padi3","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"vue"}]},{"ID":"20250510110940-9kaqr7o","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-9kaqr7o","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"\u003ctemplate\u003e\n  \u003cdiv\u003e\n    \u003cp\u003eCount: {{ count }}\u003c/p\u003e\n    \u003cbutton @click=\"increment\"\u003eIncrement\u003c/button\u003e\n    \u003cbutton @click=\"decrement\"\u003eDecrement\u003c/button\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cscript\u003e\nimport { defineComponent } from 'vue';\nimport useCounter from './useCounter';\n\nexport default defineComponent({\n  setup() {\n    const { count, increment, decrement } = useCounter(0);\n\n    return {\n      count,\n      increment,\n      decrement\n    };\n  }\n});\n\u003c/script\u003e\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-8pvhogl","Type":"NodeParagraph","Properties":{"id":"20250510110940-8pvhogl","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"这种方式不仅提高了代码的可读性和维护性，还促进了逻辑的复用，减少了重复代码。组合式API的强大之处在于它可以让你自由组合不同的逻辑块，适应各种复杂的应用需求。"}]},{"ID":"20250510110940-u5j0xyf","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510110940-u5j0xyf","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Class类 / Hooks / FP / 选项式API / 组合式API 的关系和区别"}]},{"ID":"20250510110940-boupuf1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-boupuf1","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"概括"}]},{"ID":"20250510110940-y0jcm02","Type":"NodeParagraph","Properties":{"id":"20250510110940-y0jcm02","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"我们再对以上五个概念进行简单总结："}]},{"ID":"20250510110940-evxeqsx","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-evxeqsx","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Class类"}]},{"ID":"20250510110940-y3yw7vf","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-y3yw7vf","updated":"20250510110940"},"Children":[{"ID":"20250510110940-bk5q4db","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-bk5q4db","updated":"20250510110940"},"Children":[{"ID":"20250510110940-xifkrit","Type":"NodeParagraph","Properties":{"id":"20250510110940-xifkrit","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"定义"},{"Type":"NodeText","Data":"：在JavaScript中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"class"},{"Type":"NodeText","Data":"​提供了一种创建对象的模板，包括构造函数、方法和属性等。"}]}]},{"ID":"20250510110940-qnx22ml","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-qnx22ml","updated":"20250510110940"},"Children":[{"ID":"20250510110940-5r29bke","Type":"NodeParagraph","Properties":{"id":"20250510110940-5r29bke","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"用途"},{"Type":"NodeText","Data":"：主要用于面向对象编程（OOP），允许通过继承等方式实现代码复用。"}]}]},{"ID":"20250510110940-pnxyx0x","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-pnxyx0x","updated":"20250510110940"},"Children":[{"ID":"20250510110940-6uztp0i","Type":"NodeParagraph","Properties":{"id":"20250510110940-6uztp0i","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例框架"},{"Type":"NodeText","Data":"：React早期版本使用类组件来定义组件，并且Vue 2也支持使用类来创建组件。"}]}]}]},{"ID":"20250510110940-17if94v","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-17if94v","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Hooks"}]},{"ID":"20250510110940-z1r0oef","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-z1r0oef","updated":"20250510110940"},"Children":[{"ID":"20250510110940-kag0cd4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-kag0cd4","updated":"20250510110940"},"Children":[{"ID":"20250510110940-kofepat","Type":"NodeParagraph","Properties":{"id":"20250510110940-kofepat","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"定义"},{"Type":"NodeText","Data":"：在React中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Hooks"},{"Type":"NodeText","Data":"​是一种特殊函数，允许你在不编写类的情况下使用状态和其他React特性。Vue中虽然没有直接称为“Hooks”的概念，但Vue 3中的自定义组合函数与之类似。"}]}]},{"ID":"20250510110940-zynbzkc","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-zynbzkc","updated":"20250510110940"},"Children":[{"ID":"20250510110940-d7vrzf5","Type":"NodeParagraph","Properties":{"id":"20250510110940-d7vrzf5","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"用途"},{"Type":"NodeText","Data":"：简化状态管理和生命周期管理，使得逻辑复用更加方便。"}]}]},{"ID":"20250510110940-fuxg7ub","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-fuxg7ub","updated":"20250510110940"},"Children":[{"ID":"20250510110940-oi0oaue","Type":"NodeParagraph","Properties":{"id":"20250510110940-oi0oaue","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例框架"},{"Type":"NodeText","Data":"：主要应用于React，但Vue 3的组合式API也支持类似的逻辑组织方式。"}]}]}]},{"ID":"20250510110940-p7k0akv","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-p7k0akv","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"函数式编程（FP）"}]},{"ID":"20250510110940-rf81rze","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-rf81rze","updated":"20250510110940"},"Children":[{"ID":"20250510110940-tsx5mfw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-tsx5mfw","updated":"20250510110940"},"Children":[{"ID":"20250510110940-iw1lalp","Type":"NodeParagraph","Properties":{"id":"20250510110940-iw1lalp","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"定义"},{"Type":"NodeText","Data":"：一种编程范式，强调使用纯函数、避免共享状态、可变数据和副作用。"}]}]},{"ID":"20250510110940-2wl0j02","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-2wl0j02","updated":"20250510110940"},"Children":[{"ID":"20250510110940-iyoz6gd","Type":"NodeParagraph","Properties":{"id":"20250510110940-iyoz6gd","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"用途"},{"Type":"NodeText","Data":"：提高代码的清晰度、可测试性和可维护性。React和Vue 3都鼓励使用函数式编程的原则。"}]}]},{"ID":"20250510110940-eptgtmg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-eptgtmg","updated":"20250510110940"},"Children":[{"ID":"20250510110940-namnsck","Type":"NodeParagraph","Properties":{"id":"20250510110940-namnsck","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例框架"},{"Type":"NodeText","Data":"：React通过Hooks促进了函数式编程风格；Vue 3则通过组合式API支持了更多的函数式编程实践。"}]}]}]},{"ID":"20250510110940-7ta90id","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-7ta90id","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"选项式API（Options API）"}]},{"ID":"20250510110940-7t2zgmz","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-7t2zgmz","updated":"20250510110940"},"Children":[{"ID":"20250510110940-otiulca","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-otiulca","updated":"20250510110940"},"Children":[{"ID":"20250510110940-86vyuot","Type":"NodeParagraph","Properties":{"id":"20250510110940-86vyuot","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"定义"},{"Type":"NodeText","Data":"：Vue.js的一种编程模式，通过将组件的不同部分（如data, methods, computed等）作为选项添加到一个对象中来定义组件。"}]}]},{"ID":"20250510110940-y8kwmv6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-y8kwmv6","updated":"20250510110940"},"Children":[{"ID":"20250510110940-teunni5","Type":"NodeParagraph","Properties":{"id":"20250510110940-teunni5","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"用途"},{"Type":"NodeText","Data":"：提供了一种直观的方式来组织组件逻辑，特别适合初学者理解和使用。"}]}]},{"ID":"20250510110940-v7hqu9g","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-v7hqu9g","updated":"20250510110940"},"Children":[{"ID":"20250510110940-cbkxl1z","Type":"NodeParagraph","Properties":{"id":"20250510110940-cbkxl1z","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例框架"},{"Type":"NodeText","Data":"：主要应用于Vue 2及Vue 3中，用于构建Vue组件。"}]}]}]},{"ID":"20250510110940-7r6ybqm","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-7r6ybqm","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"组合式API（Composition API）"}]},{"ID":"20250510110940-bsgen2m","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-bsgen2m","updated":"20250510110940"},"Children":[{"ID":"20250510110940-zklv6u9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-zklv6u9","updated":"20250510110940"},"Children":[{"ID":"20250510110940-5wxkxk4","Type":"NodeParagraph","Properties":{"id":"20250510110940-5wxkxk4","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"定义"},{"Type":"NodeText","Data":"：Vue 3引入的一种新的编程模式，允许开发者基于功能而非类型来组织代码，通常通过"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"setup"},{"Type":"NodeText","Data":"​函数实现。"}]}]},{"ID":"20250510110940-ygn663d","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-ygn663d","updated":"20250510110940"},"Children":[{"ID":"20250510110940-1sp5ivf","Type":"NodeParagraph","Properties":{"id":"20250510110940-1sp5ivf","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"用途"},{"Type":"NodeText","Data":"：增强了代码的灵活性和复用性，特别是在处理复杂逻辑时表现尤为突出。"}]}]},{"ID":"20250510110940-qld00ki","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-qld00ki","updated":"20250510110940"},"Children":[{"ID":"20250510110940-izpr36y","Type":"NodeParagraph","Properties":{"id":"20250510110940-izpr36y","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"示例框架"},{"Type":"NodeText","Data":"：Vue 3中推荐的方式，也可以用于React中的某些高级场景（尽管React本身更倾向于使用Hooks）。"}]}]}]},{"ID":"20250510110940-bnh4gyv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-bnh4gyv","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"关系和区别"}]},{"ID":"20250510110940-22cjdcp","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-22cjdcp","updated":"20250510110940"},"Children":[{"ID":"20250510110940-9014g4h","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-9014g4h","updated":"20250510110940"},"Children":[{"ID":"20250510110940-2jc0l9b","Type":"NodeParagraph","Properties":{"id":"20250510110940-2jc0l9b","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Class vs. 函数式编程"},{"Type":"NodeText","Data":"：Class是面向对象编程的核心，而函数式编程则追求无状态和不可变的数据流。两者代表了不同的编程哲学。"}]}]},{"ID":"20250510110940-wd4kzpo","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-wd4kzpo","updated":"20250510110940"},"Children":[{"ID":"20250510110940-003d03n","Type":"NodeParagraph","Properties":{"id":"20250510110940-003d03n","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Hooks vs. 组合式API"},{"Type":"NodeText","Data":"：虽然名称不同，但两者的目的相似，都是为了增强逻辑复用性和代码组织的灵活性。React的Hooks和Vue 3的组合式API都可以看作是函数式编程原则的应用。"}]}]},{"ID":"20250510110940-hl3czns","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-hl3czns","updated":"20250510110940"},"Children":[{"ID":"20250510110940-m3w7a7a","Type":"NodeParagraph","Properties":{"id":"20250510110940-m3w7a7a","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"选项式API vs. 组合式API"},{"Type":"NodeText","Data":"：选项式API按类型组织代码，而组合式API则允许你根据功能需求自由组合逻辑。后者提供了更大的灵活性，尤其是在处理复杂的业务逻辑时。"}]}]}]},{"ID":"20250510110940-7c5ivl8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-7c5ivl8","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20250510110940-r8ejj5b","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-r8ejj5b","updated":"20250510110940"},"Children":[{"ID":"20250510110940-sz8d7rd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-sz8d7rd","updated":"20250510110940"},"Children":[{"ID":"20250510110940-66tja80","Type":"NodeParagraph","Properties":{"id":"20250510110940-66tja80","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Class类"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"函数式编程"},{"Type":"NodeText","Data":"代表了两种不同的编程范式，前者侧重于对象和类的关系，后者则强调纯函数和不可变数据。"}]}]},{"ID":"20250510110940-4h93xz8","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-4h93xz8","updated":"20250510110940"},"Children":[{"ID":"20250510110940-wohv1cc","Type":"NodeParagraph","Properties":{"id":"20250510110940-wohv1cc","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Hooks"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"组合式API"},{"Type":"NodeText","Data":"都是为了应对传统组件化开发中遇到的问题（如逻辑复用困难）而提出的解决方案，它们使代码更加模块化和易于维护。"}]}]},{"ID":"20250510110940-9t7gsa9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-9t7gsa9","updated":"20250510110940"},"Children":[{"ID":"20250510110940-750c60l","Type":"NodeParagraph","Properties":{"id":"20250510110940-750c60l","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"选项式API"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"组合式API"},{"Type":"NodeText","Data":"则是Vue框架内部提供的两种不同的编码风格，前者更适合初学者和小型项目，后者则为大型应用提供了更强的灵活性和扩展能力。"}]}]}]},{"ID":"20250510110940-4kuo5nn","Type":"NodeParagraph","Properties":{"id":"20250510110940-4kuo5nn","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"简单画张图表达他们的关系："}]},{"ID":"20250510110940-49hfowj","Type":"NodeParagraph","Properties":{"id":"20250510110940-49hfowj","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image-20250227172813931"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://www.helloimg.com/i/2025/02/27/67c0658c09d48.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250510110940-z40cshf","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510110940-z40cshf","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Mixins 混入"}]},{"ID":"20250510110940-s4nebph","Type":"NodeParagraph","Properties":{"id":"20250510110940-s4nebph","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"前端开发中，特别是在Vue.js框架里，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"mixins"},{"Type":"NodeText","Data":"（混入）是一种用于分发Vue组件可复用功能的灵活方式。Mixin本质上是一个包含部分选项的对象，这些选项可以被混入到其他组件中，从而让多个组件共享相同的逻辑或行为。通过这种方式，你可以避免重复代码，并促进代码的复用性。"}]},{"ID":"20250510110940-ykid4z4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-ykid4z4","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"原理"}]},{"ID":"20250510110940-mqro6ac","Type":"NodeParagraph","Properties":{"id":"20250510110940-mqro6ac","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"当你将一个mixin对象传递给Vue组件时，该mixin中的选项会与组件自身的选项进行“合并”。对于大多数选项来说，如果组件和mixin都定义了相同的选项，它们的内容会被合并而不是覆盖。但是，对于某些特定选项（如生命周期钩子），mixin和组件的钩子都会被调用。"}]},{"ID":"20250510110940-mx351wb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-mx351wb","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"示例"}]},{"ID":"20250510110940-uigofc7","Type":"NodeParagraph","Properties":{"id":"20250510110940-uigofc7","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"基本使用"},{"Type":"NodeText","Data":"：假设我们有一个需要在多个组件中使用的通用功能，比如获取当前时间并格式化显示"}]},{"ID":"20250510110940-chm4s06","Type":"NodeParagraph","Properties":{"id":"20250510110940-chm4s06","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"vue"}]},{"ID":"20250510110940-a0z3489","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-a0z3489","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// 定义一个mixin\nconst datetimeMixin = {\n  data() {\n    return {\n      currentTime: new Date(),\n    };\n  },\n  methods: {\n    formatTime(date) {\n      const hours = date.getHours().toString().padStart(2, '0');\n      const minutes = date.getMinutes().toString().padStart(2, '0');\n      return `${hours}:${minutes}`;\n    }\n  },\n  mounted() {\n    setInterval(() =\u003e {\n      this.currentTime = new Date();\n    }, 1000);\n  }\n};\n\n// 使用mixin的组件\n\u003ctemplate\u003e\n  \u003cdiv\u003e\n    \u003cp\u003eCurrent Time: {{ formattedTime }}\u003c/p\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cscript\u003e\nexport default {\n  mixins: [datetimeMixin],\n  computed: {\n    formattedTime() {\n      return this.formatTime(this.currentTime);\n    }\n  }\n};\n\u003c/script\u003e\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-l6j6l5j","Type":"NodeParagraph","Properties":{"id":"20250510110940-l6j6l5j","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在这个例子中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"datetimeMixin"},{"Type":"NodeText","Data":"​提供了一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"currentTime"},{"Type":"NodeText","Data":"​的数据属性、一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"formatTime"},{"Type":"NodeText","Data":"​的方法以及一个定时更新当前时间的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mounted"},{"Type":"NodeText","Data":"​生命周期钩子。任何使用这个mixin的组件都可以直接访问这些属性和方法。"}]},{"ID":"20250510110940-kp6c871","Type":"NodeParagraph","Properties":{"id":"20250510110940-kp6c871","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"处理冲突"},{"Type":"NodeText","Data":"：当组件和mixin都定义了相同的选项时，Vue提供了默认的合并策略来处理这种情况。例如，对于methods、components和directives，它们会简单地合并成一个对象；如果有重复的名字，则组件的选项会覆盖mixin的选项。"}]},{"ID":"20250510110940-560gyl2","Type":"NodeParagraph","Properties":{"id":"20250510110940-560gyl2","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-lz33hyj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-lz33hyj","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// 定义两个mixin\nconst mixin1 = {\n  methods: {\n    sayHello() {\n      console.log('Hello from mixin1');\n    }\n  }\n};\n\nconst mixin2 = {\n  methods: {\n    sayHello() {\n      console.log('Hello from mixin2');\n    },\n    sayGoodbye() {\n      console.log('Goodbye from mixin2');\n    }\n  }\n};\n\n// 组件\nexport default {\n  mixins: [mixin1, mixin2],\n  created() {\n    this.sayHello(); // 输出 \"Hello from mixin2\"\n    this.sayGoodbye(); // 输出 \"Goodbye from mixin2\"\n  }\n};\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-gw8mha6","Type":"NodeParagraph","Properties":{"id":"20250510110940-gw8mha6","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在这个例子中，尽管"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mixin1"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mixin2"},{"Type":"NodeText","Data":"​都定义了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"sayHello"},{"Type":"NodeText","Data":"​方法，但最终调用的是来自"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mixin2"},{"Type":"NodeText","Data":"​的版本，因为后定义的mixin优先级更高。"}]},{"ID":"20250510110940-2y3smho","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-2y3smho","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20250510110940-a2g6thx","Type":"NodeParagraph","Properties":{"id":"20250510110940-a2g6thx","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"虽然mixins是提高代码复用性的有力工具，但在使用时也需要注意一些潜在的问题："}]},{"ID":"20250510110940-671gz1c","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-671gz1c","updated":"20250510110940"},"Children":[{"ID":"20250510110940-pzjtzlk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-pzjtzlk","updated":"20250510110940"},"Children":[{"ID":"20250510110940-dhkt5x8","Type":"NodeParagraph","Properties":{"id":"20250510110940-dhkt5x8","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"命名冲突"},{"Type":"NodeText","Data":"：如果不同的mixin定义了相同名称的选项或变量，可能会导致意外的行为。"}]}]},{"ID":"20250510110940-npzagtk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-npzagtk","updated":"20250510110940"},"Children":[{"ID":"20250510110940-3sipjws","Type":"NodeParagraph","Properties":{"id":"20250510110940-3sipjws","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"复杂性增加"},{"Type":"NodeText","Data":"：过度使用mixins可能导致组件变得难以理解和维护，特别是当多个mixin相互依赖或重叠时。"}]}]},{"ID":"20250510110940-ie8h041","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-ie8h041","updated":"20250510110940"},"Children":[{"ID":"20250510110940-2p71kez","Type":"NodeParagraph","Properties":{"id":"20250510110940-2p71kez","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"隐式依赖"},{"Type":"NodeText","Data":"：Mixins可能引入隐式的依赖关系，这使得追踪数据流变得更加困难。"}]}]}]},{"ID":"20250510110940-17d7zl5","Type":"NodeParagraph","Properties":{"id":"20250510110940-17d7zl5","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"因此，在设计你的应用架构时，应谨慎考虑是否采用mixins以及如何合理地组织它们。随着Vue 3的组合式API的普及，许多原本需要使用mixins实现的功能现在可以通过组合式API以更清晰的方式达成。"}]},{"ID":"20250510110940-l45uhmg","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510110940-l45uhmg","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Hooks 和 Mixins 的关系和区别"}]},{"ID":"20250510110940-mpujz3k","Type":"NodeParagraph","Properties":{"id":"20250510110940-mpujz3k","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mixins"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Hooks"},{"Type":"NodeText","Data":"​都是为了提高代码复用性和模块化而设计的机制，但它们在实现方式、使用场景以及设计理念上存在显著的不同。"}]},{"ID":"20250510110940-t4y0ghm","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250510110940-t4y0ghm","updated":"20250510110940"},"Children":[{"ID":"20250510110940-09drt48","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250510110940-09drt48","updated":"20250510110940"},"Children":[{"ID":"20250510110940-xfcvy3p","Type":"NodeParagraph","Properties":{"id":"20250510110940-xfcvy3p","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"设计理念"}]},{"ID":"20250510110940-cu04yzi","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-cu04yzi","updated":"20250510110940"},"Children":[{"ID":"20250510110940-9pzno9m","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-9pzno9m","updated":"20250510110940"},"Children":[{"ID":"20250510110940-ma1upe0","Type":"NodeParagraph","Properties":{"id":"20250510110940-ma1upe0","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Mixins倾向于通过横向组合来扩展功能，即不同来源的功能片段被组合在一起形成完整的组件。"}]}]},{"ID":"20250510110940-docfvlo","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-docfvlo","updated":"20250510110940"},"Children":[{"ID":"20250510110940-h84eorv","Type":"NodeParagraph","Properties":{"id":"20250510110940-h84eorv","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Hooks则侧重于纵向切分，围绕特定功能（如状态管理、数据获取等）组织代码，使每个Hook专注于单一职责。"}]}]}]}]},{"ID":"20250510110940-1ruqnun","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250510110940-1ruqnun","updated":"20250510110940"},"Children":[{"ID":"20250510110940-b745ujq","Type":"NodeParagraph","Properties":{"id":"20250510110940-b745ujq","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"代码结构"}]},{"ID":"20250510110940-zxqo33i","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-zxqo33i","updated":"20250510110940"},"Children":[{"ID":"20250510110940-w0sw9ju","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-w0sw9ju","updated":"20250510110940"},"Children":[{"ID":"20250510110940-03o46uo","Type":"NodeParagraph","Properties":{"id":"20250510110940-03o46uo","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"使用Mixins时，可能会遇到命名冲突和难以追踪的数据流问题，尤其是在大型项目中。"}]}]},{"ID":"20250510110940-jr4nbpd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-jr4nbpd","updated":"20250510110940"},"Children":[{"ID":"20250510110940-nam6l01","Type":"NodeParagraph","Properties":{"id":"20250510110940-nam6l01","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Hooks通过显式的输入输出参数传递依赖关系，减少了意外副作用的可能性，同时保持了良好的局部性。"}]}]}]}]},{"ID":"20250510110940-gzfjno8","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250510110940-gzfjno8","updated":"20250510110940"},"Children":[{"ID":"20250510110940-h3iysce","Type":"NodeParagraph","Properties":{"id":"20250510110940-h3iysce","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"适用范围"}]},{"ID":"20250510110940-grilnq3","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-grilnq3","updated":"20250510110940"},"Children":[{"ID":"20250510110940-im58ys6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-im58ys6","updated":"20250510110940"},"Children":[{"ID":"20250510110940-y7ztk4t","Type":"NodeParagraph","Properties":{"id":"20250510110940-y7ztk4t","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Mixins适用于需要跨多个组件共享通用行为的情况，但在复杂场景下可能导致维护成本上升。"}]}]},{"ID":"20250510110940-mi0spl2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-mi0spl2","updated":"20250510110940"},"Children":[{"ID":"20250510110940-9i36vsp","Type":"NodeParagraph","Properties":{"id":"20250510110940-9i36vsp","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Hooks更适合现代前端开发的趋势，尤其是对于追求高内聚低耦合的应用来说，Hooks提供了一种更加直观和灵活的方式来组织和重用逻辑。"}]}]}]}]},{"ID":"20250510110940-8dsclds","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20250510110940-8dsclds","updated":"20250510110940"},"Children":[{"ID":"20250510110940-tmtucqa","Type":"NodeParagraph","Properties":{"id":"20250510110940-tmtucqa","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"框架支持"}]},{"ID":"20250510110940-1xl80b8","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-1xl80b8","updated":"20250510110940"},"Children":[{"ID":"20250510110940-03mwmd2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-03mwmd2","updated":"20250510110940"},"Children":[{"ID":"20250510110940-jio6qnc","Type":"NodeParagraph","Properties":{"id":"20250510110940-jio6qnc","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Mixins主要应用于Vue.js中，尽管在其他语言或框架中也有类似的概念。"}]}]},{"ID":"20250510110940-vpr7ee1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-vpr7ee1","updated":"20250510110940"},"Children":[{"ID":"20250510110940-l1bpfrs","Type":"NodeParagraph","Properties":{"id":"20250510110940-l1bpfrs","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Hooks最初由React引入，随后影响到了Vue 3的设计，Vue 3的组合式API提供了类似于Hooks的功能，用于逻辑复用和组件构建。"}]}]}]}]}]},{"ID":"20250510110940-laqd7ya","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-laqd7ya","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20250510110940-9mifl4a","Type":"NodeParagraph","Properties":{"id":"20250510110940-9mifl4a","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"总之，虽然Mixins和Hooks都能帮助开发者提高代码复用性，但Hooks因其更清晰的逻辑组织方式和更好的维护性，在现代前端开发中得到了更广泛的认可和支持。特别是在处理复杂的业务逻辑时，Hooks通常能提供更为简洁有效的解决方案。"}]},{"ID":"20250510110940-nwdw4m1","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250510110940-nwdw4m1","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"生命周期 Lifecycle"}]},{"ID":"20250510110940-crwgge3","Type":"NodeParagraph","Properties":{"id":"20250510110940-crwgge3","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"在前端开发中，尤其是使用框架如 React 或 Vue 时，  "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"“生命周期” 指的是组件从创建到销毁的整个过程中的不同阶段"},{"Type":"NodeText","Data":"。每个阶段都有特定的钩子（Hooks）或方法，允许开发者执行特定的操作。理解这些生命周期概念对于有效地管理资源、优化性能和确保应用的行为符合预期至关重要。"}]},{"ID":"20250510110940-0n3wyth","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-0n3wyth","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"阶段"}]},{"ID":"20250510110940-9yzw9si","Type":"NodeParagraph","Properties":{"id":"20250510110940-9yzw9si","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"通常，一个组件的生命周期可以分为三个主要阶段：挂载（Mounting）、更新（Updating）和卸载（Unmounting）。"}]},{"ID":"20250510110940-sejh7yl","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-sejh7yl","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"示例"}]},{"ID":"20250510110940-c7tpf94","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-c7tpf94","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"React中的生命周期"}]},{"ID":"20250510110940-aw7u67x","Type":"NodeParagraph","Properties":{"id":"20250510110940-aw7u67x","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"挂载阶段 (Mounting)"},{"Type":"NodeText","Data":"  ："}]},{"ID":"20250510110940-k4qxgcr","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-k4qxgcr","updated":"20250510110940"},"Children":[{"ID":"20250510110940-jycg0a9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-jycg0a9","updated":"20250510110940"},"Children":[{"ID":"20250510110940-u9c7rqo","Type":"NodeParagraph","Properties":{"id":"20250510110940-u9c7rqo","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"当组件首次被插入到 DOM 中时会经历这个阶段。"}]}]},{"ID":"20250510110940-a3uwazj","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-a3uwazj","updated":"20250510110940"},"Children":[{"ID":"20250510110940-9jz2kmt","Type":"NodeParagraph","Properties":{"id":"20250510110940-9jz2kmt","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"主要的生命周期方法包括 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"constructor()"},{"Type":"NodeText","Data":"​（类组件），"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"componentDidMount()"},{"Type":"NodeText","Data":"​（类组件），以及在函数组件中通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"useEffect"},{"Type":"NodeText","Data":"​ 钩子模拟。"}]}]},{"ID":"20250510110940-spnca5b","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-spnca5b","updated":"20250510110940"},"Children":[{"ID":"20250510110940-ky672eu","Type":"NodeParagraph","Properties":{"id":"20250510110940-ky672eu","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"示例：在这个阶段，你可以发起网络请求获取数据，设置定时器等。"}]}]}]},{"ID":"20250510110940-n9106cm","Type":"NodeParagraph","Properties":{"id":"20250510110940-n9106cm","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"jsx"}]},{"ID":"20250510110940-jiigdei","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-jiigdei","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"useEffect(() =\u003e {\n  console.log('Component did mount');\n  return () =\u003e console.log('Cleanup on unmount'); // 清理副作用\n}, []); // 空数组意味着只在组件挂载和卸载时执行\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-v7x7os9","Type":"NodeParagraph","Properties":{"id":"20250510110940-v7x7os9","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"更新阶段 (Updating)"},{"Type":"NodeText","Data":"  ："}]},{"ID":"20250510110940-2nk3730","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-2nk3730","updated":"20250510110940"},"Children":[{"ID":"20250510110940-pgz3j2x","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-pgz3j2x","updated":"20250510110940"},"Children":[{"ID":"20250510110940-lid9pn6","Type":"NodeParagraph","Properties":{"id":"20250510110940-lid9pn6","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"当组件的状态或属性发生变化时，会触发重新渲染，进入更新阶段。"}]}]},{"ID":"20250510110940-03qs2mq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-03qs2mq","updated":"20250510110940"},"Children":[{"ID":"20250510110940-oam13hc","Type":"NodeParagraph","Properties":{"id":"20250510110940-oam13hc","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"包括 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"shouldComponentUpdate()"},{"Type":"NodeText","Data":"​（决定是否需要重新渲染），"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"render()"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"componentDidUpdate()"},{"Type":"NodeText","Data":"​（类组件），以及在函数组件中可以通过依赖项数组控制的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"useEffect"},{"Type":"NodeText","Data":"​ 来处理。"}]}]},{"ID":"20250510110940-7y9kd1t","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-7y9kd1t","updated":"20250510110940"},"Children":[{"ID":"20250510110940-m42tufu","Type":"NodeParagraph","Properties":{"id":"20250510110940-m42tufu","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"示例：可以在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"componentDidUpdate"},{"Type":"NodeText","Data":"​ 中比较前后状态或属性的变化来进行特定操作。"}]}]}]},{"ID":"20250510110940-ri5vlit","Type":"NodeParagraph","Properties":{"id":"20250510110940-ri5vlit","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"jsx"}]},{"ID":"20250510110940-dfatkkp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-dfatkkp","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"useEffect(() =\u003e {\n  console.log('Component updated');\n}, [props.someProp]); // 只有当 someProp 改变时才会触发\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-rwfp0po","Type":"NodeParagraph","Properties":{"id":"20250510110940-rwfp0po","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"卸载阶段 (Unmounting)"},{"Type":"NodeText","Data":"  ："}]},{"ID":"20250510110940-prdmtbt","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-prdmtbt","updated":"20250510110940"},"Children":[{"ID":"20250510110940-ud88dqx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-ud88dqx","updated":"20250510110940"},"Children":[{"ID":"20250510110940-6kdqici","Type":"NodeParagraph","Properties":{"id":"20250510110940-6kdqici","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"当组件从 DOM 中移除时，会调用卸载阶段的方法。"}]}]},{"ID":"20250510110940-n38cjib","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-n38cjib","updated":"20250510110940"},"Children":[{"ID":"20250510110940-zo0xgb0","Type":"NodeParagraph","Properties":{"id":"20250510110940-zo0xgb0","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"主要是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"componentWillUnmount()"},{"Type":"NodeText","Data":"​（类组件），或者在函数组件中通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"useEffect"},{"Type":"NodeText","Data":"​ 返回的清理函数实现。"}]}]},{"ID":"20250510110940-o8i8m9v","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-o8i8m9v","updated":"20250510110940"},"Children":[{"ID":"20250510110940-x7a3rpu","Type":"NodeParagraph","Properties":{"id":"20250510110940-x7a3rpu","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"示例：清除定时器、取消未完成的网络请求等。"}]}]}]},{"ID":"20250510110940-jwbi0xm","Type":"NodeParagraph","Properties":{"id":"20250510110940-jwbi0xm","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"jsx"}]},{"ID":"20250510110940-lmqimm3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-lmqimm3","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"useEffect(() =\u003e {\n  const timer = setInterval(() =\u003e console.log('Tick'), 1000);\n  return () =\u003e clearInterval(timer); // 清理定时器\n}, []);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-lxis2xp","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250510110940-lxis2xp","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"Vue 中的生命周期"}]},{"ID":"20250510110940-xeeybyy","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250510110940-xeeybyy","updated":"20250510110940"},"Children":[{"ID":"20250510110940-azsfqzx","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250510110940-azsfqzx","updated":"20250510110940"},"Children":[{"ID":"20250510110940-us0v4dd","Type":"NodeParagraph","Properties":{"id":"20250510110940-us0v4dd","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"挂载阶段"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510110940-mbbezlp","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-mbbezlp","updated":"20250510110940"},"Children":[{"ID":"20250510110940-49cuoae","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-49cuoae","updated":"20250510110940"},"Children":[{"ID":"20250510110940-1h33vcs","Type":"NodeParagraph","Properties":{"id":"20250510110940-1h33vcs","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"beforeCreate"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"created"},{"Type":"NodeText","Data":"​：实例初始化后和数据观测、事件等配置完成之前/之后。"}]}]},{"ID":"20250510110940-kvqqexu","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-kvqqexu","updated":"20250510110940"},"Children":[{"ID":"20250510110940-ptcs00f","Type":"NodeParagraph","Properties":{"id":"20250510110940-ptcs00f","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"beforeMount"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mounted"},{"Type":"NodeText","Data":"​：模板编译/虚拟DOM挂载到真实DOM前/后。"}]}]}]}]},{"ID":"20250510110940-fc0zxwp","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250510110940-fc0zxwp","updated":"20250510110940"},"Children":[{"ID":"20250510110940-933r18o","Type":"NodeParagraph","Properties":{"id":"20250510110940-933r18o","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"更新阶段"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510110940-8s8x1jh","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-8s8x1jh","updated":"20250510110940"},"Children":[{"ID":"20250510110940-51wvnbi","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-51wvnbi","updated":"20250510110940"},"Children":[{"ID":"20250510110940-l88plwm","Type":"NodeParagraph","Properties":{"id":"20250510110940-l88plwm","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"beforeUpdate"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"updated"},{"Type":"NodeText","Data":"​：当数据变化导致虚拟DOM重新渲染并在更新之前/之后触发。"}]}]}]}]},{"ID":"20250510110940-vj3kw9l","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250510110940-vj3kw9l","updated":"20250510110940"},"Children":[{"ID":"20250510110940-3r35xii","Type":"NodeParagraph","Properties":{"id":"20250510110940-3r35xii","updated":"20250510110940"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"卸载阶段"},{"Type":"NodeText","Data":"："}]},{"ID":"20250510110940-edwm0q3","Type":"NodeList","ListData":{},"Properties":{"id":"20250510110940-edwm0q3","updated":"20250510110940"},"Children":[{"ID":"20250510110940-iw1kyp7","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250510110940-iw1kyp7","updated":"20250510110940"},"Children":[{"ID":"20250510110940-vkjsmic","Type":"NodeParagraph","Properties":{"id":"20250510110940-vkjsmic","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"beforeDestroy"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"destroyed"},{"Type":"NodeText","Data":"​：实例销毁之前/之后，适合做清理工作。"}]}]}]}]}]},{"ID":"20250510110940-i5e8330","Type":"NodeParagraph","Properties":{"id":"20250510110940-i5e8330","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"js"}]},{"ID":"20250510110940-xhlbxag","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250510110940-xhlbxag","updated":"20250510110940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"export default {\n  mounted() {\n    console.log('Component has been mounted');\n  },\n  updated() {\n    console.log('Component has been updated');\n  },\n  beforeDestroy() {\n    console.log('Cleanup before component is destroyed');\n  }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250510110940-kx3bovv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250510110940-kx3bovv","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20250510110940-w0rfrpt","Type":"NodeParagraph","Properties":{"id":"20250510110940-w0rfrpt","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"生命周期的概念帮助开发者更好地控制组件的行为，特别是在资源管理和状态同步方面。无论是 React 还是 Vue，了解并合理利用生命周期钩子都能极大地提升应用的质量和性能。例如，通过在适当的生命周期钩子中加载数据或释放资源，可以避免内存泄漏和其他潜在问题。"}]},{"ID":"20250510110940-zggny9c","Type":"NodeParagraph","Properties":{"id":"20250510110940-zggny9c","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"文章作者: "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://note.weizwz.com/","TextMarkTextContent":"weizwz"}]},{"ID":"20250510110940-w1p39kk","Type":"NodeParagraph","Properties":{"id":"20250510110940-w1p39kk","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"文章链接: "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://note.weizwz.com/terminology/design-paradigm","TextMarkTextContent":"https://note.weizwz.com/terminology/design-paradigm"}]},{"ID":"20250510110940-hh1hwc8","Type":"NodeParagraph","Properties":{"id":"20250510110940-hh1hwc8","updated":"20250510110940"},"Children":[{"Type":"NodeText","Data":"版权声明: 本站文章除特别声明外，均采用 "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh","TextMarkTextContent":"BY-NC-SA 4.0"},{"Type":"NodeText","Data":" 许可协议， 转载请注明来自 "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://note.weizwz.com/","TextMarkTextContent":"唯知笔记"},{"Type":"NodeText","Data":"！"}]}]}